diff --git a/node_modules/react-native/ReactCommon/jsi/jsi/.clang-format b/node_modules/react-native/ReactCommon/jsi/jsi/.clang-format
new file mode 100644
index 0000000..90ad876
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/jsi/jsi/.clang-format
@@ -0,0 +1,5 @@
+---
+BasedOnStyle: InheritParentConfig
+PointerAlignment: Left
+ColumnLimit:      80
+...
diff --git a/node_modules/react-native/ReactCommon/jsi/jsi/CMakeLists.txt b/node_modules/react-native/ReactCommon/jsi/jsi/CMakeLists.txt
index 3d2959e..ed9bae8 100644
--- a/node_modules/react-native/ReactCommon/jsi/jsi/CMakeLists.txt
+++ b/node_modules/react-native/ReactCommon/jsi/jsi/CMakeLists.txt
@@ -20,10 +20,14 @@ elseif ("${CMAKE_CXX_COMPILER_ID}" MATCHES "MSVC")
   # Turn on Error Handling in MSVC, otherwise objects are not destructed
   # when they go out of scope due to exceptions.
   list(APPEND jsi_compile_flags "/EHsc")
+  list(APPEND jsi_compile_flags "/Zi")
+  list(APPEND jsi_compile_flags "/Qspectre")
+  list(APPEND jsi_compile_flags "/sdl")
 endif()
 if (HERMES_ENABLE_BITCODE)
   list(APPEND jsi_compile_flags "-fembed-bitcode")
 endif ()
+
 target_compile_options(jsi PRIVATE ${jsi_compile_flags})
 
 install(DIRECTORY "${PROJECT_SOURCE_DIR}/API/jsi/" DESTINATION include
diff --git a/node_modules/react-native/ReactCommon/jsi/jsi/JSIDynamic.cpp b/node_modules/react-native/ReactCommon/jsi/jsi/JSIDynamic.cpp
index 02f112c..0ff314b 100644
--- a/node_modules/react-native/ReactCommon/jsi/jsi/JSIDynamic.cpp
+++ b/node_modules/react-native/ReactCommon/jsi/jsi/JSIDynamic.cpp
@@ -139,8 +139,10 @@ void dynamicFromValueShallow(
       output = folly::dynamic::object();
     }
     stack.emplace_back(&output, std::move(obj));
+#if JSI_VERSION >= 8
   } else if (value.isBigInt()) {
     throw JSError(runtime, "JS BigInts are not convertible to dynamic");
+#endif
   } else if (value.isSymbol()) {
     throw JSError(runtime, "JS Symbols are not convertible to dynamic");
   } else {
diff --git a/node_modules/react-native/ReactCommon/jsi/jsi/README.md b/node_modules/react-native/ReactCommon/jsi/jsi/README.md
new file mode 100644
index 0000000..58ff4ed
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/jsi/jsi/README.md
@@ -0,0 +1,25 @@
+# JavaScript Interface 
+
+This folder contains definitions for JSI.
+JSI is the public API for Hermes engine.
+It is being used by React Native project to work with JS engines.
+
+## JSI versions
+
+JSI has versions associated with the following commit hashes in the 
+https://github.com/facebook/hermes repo. 
+
+| Version | Commit Hash                              | Commit Description
+|--------:|:-----------------------------------------|------------------------------------------------------
+|      10 | `b81666598672cb5f8b365fe6548d3273f216322e` | Clarify const-ness of JSI references
+|       9 | `e6d887ae96bef5c71032f11ed1a9fb9fecec7b46` | Add external ArrayBuffers to JSI
+|       8 | `4d64e61a1f9926eca0afd4eb38d17cea30bdc34c` | Add BigInt JSI API support
+|         | `e8cc57311877464478da5421265bcc898098e136` | Add methods for creating and interacting with BigInt
+|       7 | `4efad65b8266e3f26e04e3ca9addf92fc4d6ded8` | Add API for setting/getting native state
+|       6 | `bc3cfb87fbfc82732936ec4445c9765bf9a5f08a` | Add BigInt skeleton
+|       5 | `2b6d408980d7f23f50602fd88169c8a9881592a6` | Add PropNameID::fromSymbol
+|       4 | `a5bee55c8301bb8662e408feee28bbc3e2a1fc81` | Introduce drainMicrotasks to JSI
+|       3 | `0c9daa5a5eee7649558a53e3e541b80c89048c42` | Change jsi::Runtime::lockWeakObject to take a mutable ref
+|       2 | `e0616e77e1ddc3ea5e2ccbca2e20dd0c4049c637` | Make it possible for a Runtime implementation to provide its own JSON parsing
+|       1 | `3ba9615f80913764ecb6456779d502e31dde9e5d` | Fix build break in MSVC (#26462)
+|       0 | `f22a18f67da3f03db59c1ec715d6ec3776b03fbf` | Initial commit
\ No newline at end of file
diff --git a/node_modules/react-native/ReactCommon/jsi/jsi/decorator.h b/node_modules/react-native/ReactCommon/jsi/jsi/decorator.h
index baece80..19c7507 100644
--- a/node_modules/react-native/ReactCommon/jsi/jsi/decorator.h
+++ b/node_modules/react-native/ReactCommon/jsi/jsi/decorator.h
@@ -126,9 +126,11 @@ class RuntimeDecorator : public Base, private jsi::Instrumentation {
       const std::shared_ptr<const PreparedJavaScript>& js) override {
     return plain().evaluatePreparedJavaScript(js);
   }
+#if JSI_VERSION >= 4
   bool drainMicrotasks(int maxMicrotasksHint) override {
     return plain().drainMicrotasks(maxMicrotasksHint);
   }
+#endif
   Object global() override {
     return plain().global();
   }
@@ -154,9 +156,11 @@ class RuntimeDecorator : public Base, private jsi::Instrumentation {
   Runtime::PointerValue* cloneSymbol(const Runtime::PointerValue* pv) override {
     return plain_.cloneSymbol(pv);
   };
+#if JSI_VERSION >= 6
   Runtime::PointerValue* cloneBigInt(const Runtime::PointerValue* pv) override {
     return plain_.cloneBigInt(pv);
   };
+#endif
   Runtime::PointerValue* cloneString(const Runtime::PointerValue* pv) override {
     return plain_.cloneString(pv);
   };
@@ -179,9 +183,11 @@ class RuntimeDecorator : public Base, private jsi::Instrumentation {
   PropNameID createPropNameIDFromString(const String& str) override {
     return plain_.createPropNameIDFromString(str);
   };
+#if JSI_VERSION >= 5
   PropNameID createPropNameIDFromSymbol(const Symbol& sym) override {
     return plain_.createPropNameIDFromSymbol(sym);
   };
+#endif
   std::string utf8(const PropNameID& id) override {
     return plain_.utf8(id);
   };
@@ -193,6 +199,7 @@ class RuntimeDecorator : public Base, private jsi::Instrumentation {
     return plain_.symbolToString(sym);
   }
 
+#if JSI_VERSION >= 8
   BigInt createBigIntFromInt64(int64_t value) override {
     return plain_.createBigIntFromInt64(value);
   }
@@ -211,6 +218,7 @@ class RuntimeDecorator : public Base, private jsi::Instrumentation {
   String bigintToString(const BigInt& bigint, int radix) override {
     return plain_.bigintToString(bigint, radix);
   }
+#endif
 
   String createStringFromAscii(const char* str, size_t length) override {
     return plain_.createStringFromAscii(str, length);
@@ -241,6 +249,7 @@ class RuntimeDecorator : public Base, private jsi::Instrumentation {
     return dhf.target<DecoratedHostFunction>()->plainHF_;
   };
 
+#if JSI_VERSION >= 7
   bool hasNativeState(const Object& o) override {
     return plain_.hasNativeState(o);
   }
@@ -251,6 +260,7 @@ class RuntimeDecorator : public Base, private jsi::Instrumentation {
       override {
     plain_.setNativeState(o, state);
   }
+#endif
 
   Value getProperty(const Object& o, const PropNameID& name) override {
     return plain_.getProperty(o, name);
@@ -265,13 +275,15 @@ class RuntimeDecorator : public Base, private jsi::Instrumentation {
     return plain_.hasProperty(o, name);
   };
   void setPropertyValue(
-      const Object& o,
+      JSI_CONST_10 Object& o,
       const PropNameID& name,
       const Value& value) override {
     plain_.setPropertyValue(o, name, value);
   };
-  void setPropertyValue(const Object& o, const String& name, const Value& value)
-      override {
+  void setPropertyValue(
+      JSI_CONST_10 Object& o,
+      const String& name,
+      const Value& value) override {
     plain_.setPropertyValue(o, name, value);
   };
 
@@ -297,17 +309,19 @@ class RuntimeDecorator : public Base, private jsi::Instrumentation {
   WeakObject createWeakObject(const Object& o) override {
     return plain_.createWeakObject(o);
   };
-  Value lockWeakObject(const WeakObject& wo) override {
+  Value lockWeakObject(JSI_NO_CONST_3 JSI_CONST_10 WeakObject& wo) override {
     return plain_.lockWeakObject(wo);
   };
 
   Array createArray(size_t length) override {
     return plain_.createArray(length);
   };
+#if JSI_VERSION >= 9
   ArrayBuffer createArrayBuffer(
       std::shared_ptr<MutableBuffer> buffer) override {
     return plain_.createArrayBuffer(std::move(buffer));
   };
+#endif
   size_t size(const Array& a) override {
     return plain_.size(a);
   };
@@ -320,7 +334,7 @@ class RuntimeDecorator : public Base, private jsi::Instrumentation {
   Value getValueAtIndex(const Array& a, size_t i) override {
     return plain_.getValueAtIndex(a, i);
   };
-  void setValueAtIndexImpl(const Array& a, size_t i, const Value& value)
+  void setValueAtIndexImpl(JSI_CONST_10 Array& a, size_t i, const Value& value)
       override {
     plain_.setValueAtIndexImpl(a, i, value);
   };
@@ -355,9 +369,11 @@ class RuntimeDecorator : public Base, private jsi::Instrumentation {
   bool strictEquals(const Symbol& a, const Symbol& b) const override {
     return plain_.strictEquals(a, b);
   };
+#if JSI_VERSION >= 6
   bool strictEquals(const BigInt& a, const BigInt& b) const override {
     return plain_.strictEquals(a, b);
   };
+#endif
   bool strictEquals(const String& a, const String& b) const override {
     return plain_.strictEquals(a, b);
   };
@@ -540,10 +556,12 @@ class WithRuntimeDecorator : public RuntimeDecorator<Plain, Base> {
     Around around{with_};
     return RD::evaluatePreparedJavaScript(js);
   }
+#if JSI_VERSION >= 4
   bool drainMicrotasks(int maxMicrotasksHint) override {
     Around around{with_};
     return RD::drainMicrotasks(maxMicrotasksHint);
   }
+#endif
   Object global() override {
     Around around{with_};
     return RD::global();
@@ -660,14 +678,16 @@ class WithRuntimeDecorator : public RuntimeDecorator<Plain, Base> {
     return RD::hasProperty(o, name);
   };
   void setPropertyValue(
-      const Object& o,
+      JSI_CONST_10 Object& o,
       const PropNameID& name,
       const Value& value) override {
     Around around{with_};
     RD::setPropertyValue(o, name, value);
   };
-  void setPropertyValue(const Object& o, const String& name, const Value& value)
-      override {
+  void setPropertyValue(
+      JSI_CONST_10 Object& o,
+      const String& name,
+      const Value& value) override {
     Around around{with_};
     RD::setPropertyValue(o, name, value);
   };
@@ -701,7 +721,7 @@ class WithRuntimeDecorator : public RuntimeDecorator<Plain, Base> {
     Around around{with_};
     return RD::createWeakObject(o);
   };
-  Value lockWeakObject(const WeakObject& wo) override {
+  Value lockWeakObject(JSI_NO_CONST_3 JSI_CONST_10 WeakObject& wo) override {
     Around around{with_};
     return RD::lockWeakObject(wo);
   };
@@ -710,10 +730,12 @@ class WithRuntimeDecorator : public RuntimeDecorator<Plain, Base> {
     Around around{with_};
     return RD::createArray(length);
   };
+#if JSI_VERSION >= 9
   ArrayBuffer createArrayBuffer(
       std::shared_ptr<MutableBuffer> buffer) override {
     return RD::createArrayBuffer(std::move(buffer));
   };
+#endif
   size_t size(const Array& a) override {
     Around around{with_};
     return RD::size(a);
@@ -730,7 +752,7 @@ class WithRuntimeDecorator : public RuntimeDecorator<Plain, Base> {
     Around around{with_};
     return RD::getValueAtIndex(a, i);
   };
-  void setValueAtIndexImpl(const Array& a, size_t i, const Value& value)
+  void setValueAtIndexImpl(JSI_CONST_10 Array& a, size_t i, const Value& value)
       override {
     Around around{with_};
     RD::setValueAtIndexImpl(a, i, value);
diff --git a/node_modules/react-native/ReactCommon/jsi/jsi/jsi-inl.h b/node_modules/react-native/ReactCommon/jsi/jsi/jsi-inl.h
index 4ce00ad..1b7ad93 100644
--- a/node_modules/react-native/ReactCommon/jsi/jsi/jsi-inl.h
+++ b/node_modules/react-native/ReactCommon/jsi/jsi/jsi-inl.h
@@ -70,9 +70,11 @@ inline T Runtime::make(Runtime::PointerValue* pv) {
   return T(pv);
 }
 
+#if JSI_VERSION >= 3
 inline Runtime::PointerValue* Runtime::getPointerValue(jsi::Pointer& pointer) {
   return pointer.ptr_;
 }
+#endif
 
 inline const Runtime::PointerValue* Runtime::getPointerValue(
     const jsi::Pointer& pointer) {
@@ -111,21 +113,22 @@ inline bool Object::hasProperty(Runtime& runtime, const PropNameID& name)
 }
 
 template <typename T>
-void Object::setProperty(Runtime& runtime, const char* name, T&& value) const {
+void Object::setProperty(Runtime& runtime, const char* name, T&& value)
+    JSI_CONST_10 {
   setProperty(
       runtime, String::createFromAscii(runtime, name), std::forward<T>(value));
 }
 
 template <typename T>
 void Object::setProperty(Runtime& runtime, const String& name, T&& value)
-    const {
+    JSI_CONST_10 {
   setPropertyValue(
       runtime, name, detail::toValue(runtime, std::forward<T>(value)));
 }
 
 template <typename T>
 void Object::setProperty(Runtime& runtime, const PropNameID& name, T&& value)
-    const {
+    JSI_CONST_10 {
   setPropertyValue(
       runtime, name, detail::toValue(runtime, std::forward<T>(value)));
 }
@@ -204,6 +207,7 @@ inline std::shared_ptr<HostObject> Object::getHostObject<HostObject>(
   return runtime.getHostObject(*this);
 }
 
+#if JSI_VERSION >= 7
 template <typename T>
 inline bool Object::hasNativeState(Runtime& runtime) const {
   return runtime.hasNativeState(*this) &&
@@ -226,17 +230,19 @@ inline void Object::setNativeState(
     std::shared_ptr<NativeState> state) const {
   runtime.setNativeState(*this, state);
 }
+#endif
 
 inline Array Object::getPropertyNames(Runtime& runtime) const {
   return runtime.getPropertyNames(*this);
 }
 
-inline Value WeakObject::lock(Runtime& runtime) const {
+inline Value WeakObject::lock(Runtime& runtime) JSI_CONST_10 {
   return runtime.lockWeakObject(*this);
 }
 
 template <typename T>
-void Array::setValueAtIndex(Runtime& runtime, size_t i, T&& value) const {
+void Array::setValueAtIndex(Runtime& runtime, size_t i, T&& value)
+    JSI_CONST_10 {
   setValueAtIndexImpl(
       runtime, i, detail::toValue(runtime, std::forward<T>(value)));
 }
@@ -314,7 +320,7 @@ inline std::vector<PropNameID> PropNameID::names(
 
 template <size_t N>
 inline std::vector<PropNameID> PropNameID::names(
-    PropNameID(&&propertyNames)[N]) {
+    PropNameID (&&propertyNames)[N]) {
   std::vector<PropNameID> result;
   result.reserve(N);
   for (auto& name : propertyNames) {
@@ -343,9 +349,11 @@ inline Value Function::callAsConstructor(Runtime& runtime, Args&&... args)
       runtime, {detail::toValue(runtime, std::forward<Args>(args))...});
 }
 
+#if JSI_VERSION >= 8
 String BigInt::toString(Runtime& runtime, int radix) const {
   return runtime.bigintToString(*this, radix);
 }
+#endif
 
 } // namespace jsi
 } // namespace facebook
diff --git a/node_modules/react-native/ReactCommon/jsi/jsi/jsi.cpp b/node_modules/react-native/ReactCommon/jsi/jsi/jsi.cpp
index 2d1003f..9997f5f 100644
--- a/node_modules/react-native/ReactCommon/jsi/jsi/jsi.cpp
+++ b/node_modules/react-native/ReactCommon/jsi/jsi/jsi.cpp
@@ -32,8 +32,10 @@ std::string kindToString(const Value& v, Runtime* rt = nullptr) {
     return "a string";
   } else if (v.isSymbol()) {
     return "a symbol";
+#if JSI_VERSION >= 6
   } else if (v.isBigInt()) {
     return "a bigint";
+#endif
   } else {
     assert(v.isObject() && "Expecting object.");
     return rt != nullptr && v.getObject(*rt).isFunction(*rt) ? "a function"
@@ -66,7 +68,9 @@ Value callGlobalFunction(Runtime& runtime, const char* name, const Value& arg) {
 
 Buffer::~Buffer() = default;
 
+#if JSI_VERSION >= 9
 MutableBuffer::~MutableBuffer() = default;
+#endif
 
 PreparedJavaScript::~PreparedJavaScript() = default;
 
@@ -83,7 +87,9 @@ void HostObject::set(Runtime& rt, const PropNameID& name, const Value&) {
 
 HostObject::~HostObject() {}
 
+#if JSI_VERSION >= 7
 NativeState::~NativeState() {}
+#endif
 
 Runtime::~Runtime() {}
 
@@ -136,12 +142,24 @@ Instrumentation& Runtime::instrumentation() {
   return sharedInstance;
 }
 
+#if JSI_VERSION >= 2
 Value Runtime::createValueFromJsonUtf8(const uint8_t* json, size_t length) {
   Function parseJson = global()
                            .getPropertyAsObject(*this, "JSON")
                            .getPropertyAsFunction(*this, "parse");
   return parseJson.call(*this, String::createFromUtf8(*this, json, length));
 }
+#else
+Value Value::createFromJsonUtf8(
+    Runtime& runtime,
+    const uint8_t* json,
+    size_t length) {
+  Function parseJson = runtime.global()
+                           .getPropertyAsObject(runtime, "JSON")
+                           .getPropertyAsFunction(runtime, "parse");
+  return parseJson.call(runtime, String::createFromUtf8(runtime, json, length));
+}
+#endif
 
 Pointer& Pointer::operator=(Pointer&& other) {
   if (ptr_) {
@@ -240,8 +258,10 @@ Value::Value(Runtime& runtime, const Value& other) : Value(other.kind_) {
     data_.number = other.data_.number;
   } else if (kind_ == SymbolKind) {
     new (&data_.pointer) Pointer(runtime.cloneSymbol(other.data_.pointer.ptr_));
+#if JSI_VERSION >= 6
   } else if (kind_ == BigIntKind) {
     new (&data_.pointer) Pointer(runtime.cloneBigInt(other.data_.pointer.ptr_));
+#endif
   } else if (kind_ == StringKind) {
     new (&data_.pointer) Pointer(runtime.cloneString(other.data_.pointer.ptr_));
   } else if (kind_ >= ObjectKind) {
@@ -271,10 +291,12 @@ bool Value::strictEquals(Runtime& runtime, const Value& a, const Value& b) {
       return runtime.strictEquals(
           static_cast<const Symbol&>(a.data_.pointer),
           static_cast<const Symbol&>(b.data_.pointer));
+#if JSI_VERSION >= 6
     case BigIntKind:
       return runtime.strictEquals(
           static_cast<const BigInt&>(a.data_.pointer),
           static_cast<const BigInt&>(b.data_.pointer));
+#endif
     case StringKind:
       return runtime.strictEquals(
           static_cast<const String&>(a.data_.pointer),
@@ -342,6 +364,7 @@ Symbol Value::asSymbol(Runtime& rt) && {
   return std::move(*this).getSymbol(rt);
 }
 
+#if JSI_VERSION >= 6
 BigInt Value::asBigInt(Runtime& rt) const& {
   if (!isBigInt()) {
     throw JSError(
@@ -359,6 +382,7 @@ BigInt Value::asBigInt(Runtime& rt) && {
 
   return std::move(*this).getBigInt(rt);
 }
+#endif
 
 String Value::asString(Runtime& rt) const& {
   if (!isString()) {
@@ -383,6 +407,7 @@ String Value::toString(Runtime& runtime) const {
   return toString.call(runtime, *this).getString(runtime);
 }
 
+#if JSI_VERSION >= 8
 uint64_t BigInt::asUint64(Runtime& runtime) const {
   if (!isUint64(runtime)) {
     throw JSError(runtime, "Lossy truncation in BigInt64::asUint64");
@@ -396,6 +421,7 @@ int64_t BigInt::asInt64(Runtime& runtime) const {
   }
   return getInt64(runtime);
 }
+#endif
 
 Array Array::createWithElements(
     Runtime& rt,
@@ -450,12 +476,6 @@ JSError::JSError(std::string what, Runtime& rt, Value&& value)
   setValue(rt, std::move(value));
 }
 
-JSError::JSError(Value&& value, std::string message, std::string stack)
-    : JSIException(message + "\n\n" + stack),
-      value_(std::make_shared<Value>(std::move(value))),
-      message_(std::move(message)),
-      stack_(std::move(stack)) {}
-
 void JSError::setValue(Runtime& rt, Value&& value) {
   value_ = std::make_shared<Value>(std::move(value));
 
diff --git a/node_modules/react-native/ReactCommon/jsi/jsi/jsi.h b/node_modules/react-native/ReactCommon/jsi/jsi/jsi.h
index e5112b7..36c90e0 100644
--- a/node_modules/react-native/ReactCommon/jsi/jsi/jsi.h
+++ b/node_modules/react-native/ReactCommon/jsi/jsi/jsi.h
@@ -27,6 +27,24 @@
 #endif // _MSC_VER
 #endif // !defined(JSI_EXPORT)
 
+// JSI version defines set of features available in the API.
+// Each significant API change must be under a new version.
+#ifndef JSI_VERSION
+#define JSI_VERSION 10
+#endif
+
+#if JSI_VERSION >= 3
+#define JSI_NO_CONST_3
+#else
+#define JSI_NO_CONST_3 const
+#endif
+
+#if JSI_VERSION >= 10
+#define JSI_CONST_10 const
+#else
+#define JSI_CONST_10
+#endif
+
 class FBJSRuntime;
 namespace facebook {
 namespace jsi {
@@ -56,6 +74,7 @@ class JSI_EXPORT StringBuffer : public Buffer {
   std::string s_;
 };
 
+#if JSI_VERSION >= 9
 /// Base class for buffers of data that need to be passed to the runtime. The
 /// result of size() and data() must not change after construction. However, the
 /// region pointed to by data() may be modified by the user or the runtime. The
@@ -67,6 +86,7 @@ class JSI_EXPORT MutableBuffer {
   virtual size_t size() const = 0;
   virtual uint8_t* data() = 0;
 };
+#endif
 
 /// PreparedJavaScript is a base class representing JavaScript which is in a
 /// form optimized for execution, in a runtime-specific way. Construct one via
@@ -84,7 +104,9 @@ class Runtime;
 class Pointer;
 class PropNameID;
 class Symbol;
+#if JSI_VERSION >= 6
 class BigInt;
+#endif
 class String;
 class Object;
 class WeakObject;
@@ -144,12 +166,14 @@ class JSI_EXPORT HostObject {
   virtual std::vector<PropNameID> getPropertyNames(Runtime& rt);
 };
 
+#if JSI_VERSION >= 7
 /// Native state (and destructor) that can be attached to any JS object
 /// using setNativeState.
 class JSI_EXPORT NativeState {
  public:
   virtual ~NativeState();
 };
+#endif
 
 /// Represents a JS runtime.  Movable, but not copyable.  Note that
 /// this object may not be thread-aware, but cannot be used safely from
@@ -209,6 +233,7 @@ class JSI_EXPORT Runtime {
   virtual Value evaluatePreparedJavaScript(
       const std::shared_ptr<const PreparedJavaScript>& js) = 0;
 
+#if JSI_VERSION >= 4
   /// Drain the JavaScript VM internal Microtask (a.k.a. Job in ECMA262) queue.
   ///
   /// \param maxMicrotasksHint a hint to tell an implementation that it should
@@ -237,6 +262,7 @@ class JSI_EXPORT Runtime {
   /// the time this is written, An implementation may swallow exceptions (JSC),
   /// may not pause (V8), and may not support bounded executions.
   virtual bool drainMicrotasks(int maxMicrotasksHint = -1) = 0;
+#endif
 
   /// \return the global object
   virtual Object global() = 0;
@@ -264,7 +290,9 @@ class JSI_EXPORT Runtime {
   friend class Pointer;
   friend class PropNameID;
   friend class Symbol;
+#if JSI_VERSION >= 6
   friend class BigInt;
+#endif
   friend class String;
   friend class Object;
   friend class WeakObject;
@@ -288,7 +316,9 @@ class JSI_EXPORT Runtime {
   };
 
   virtual PointerValue* cloneSymbol(const Runtime::PointerValue* pv) = 0;
+#if JSI_VERSION >= 6
   virtual PointerValue* cloneBigInt(const Runtime::PointerValue* pv) = 0;
+#endif
   virtual PointerValue* cloneString(const Runtime::PointerValue* pv) = 0;
   virtual PointerValue* cloneObject(const Runtime::PointerValue* pv) = 0;
   virtual PointerValue* clonePropNameID(const Runtime::PointerValue* pv) = 0;
@@ -300,18 +330,22 @@ class JSI_EXPORT Runtime {
       const uint8_t* utf8,
       size_t length) = 0;
   virtual PropNameID createPropNameIDFromString(const String& str) = 0;
+#if JSI_VERSION >= 5
   virtual PropNameID createPropNameIDFromSymbol(const Symbol& sym) = 0;
+#endif
   virtual std::string utf8(const PropNameID&) = 0;
   virtual bool compare(const PropNameID&, const PropNameID&) = 0;
 
   virtual std::string symbolToString(const Symbol&) = 0;
 
+#if JSI_VERSION >= 8
   virtual BigInt createBigIntFromInt64(int64_t) = 0;
   virtual BigInt createBigIntFromUint64(uint64_t) = 0;
   virtual bool bigintIsInt64(const BigInt&) = 0;
   virtual bool bigintIsUint64(const BigInt&) = 0;
   virtual uint64_t truncate(const BigInt&) = 0;
   virtual String bigintToString(const BigInt&, int) = 0;
+#endif
 
   virtual String createStringFromAscii(const char* str, size_t length) = 0;
   virtual String createStringFromUtf8(const uint8_t* utf8, size_t length) = 0;
@@ -319,29 +353,35 @@ class JSI_EXPORT Runtime {
 
   // \return a \c Value created from a utf8-encoded JSON string. The default
   // implementation creates a \c String and invokes JSON.parse.
+#if JSI_VERSION >= 2
   virtual Value createValueFromJsonUtf8(const uint8_t* json, size_t length);
+#endif
 
   virtual Object createObject() = 0;
   virtual Object createObject(std::shared_ptr<HostObject> ho) = 0;
   virtual std::shared_ptr<HostObject> getHostObject(const jsi::Object&) = 0;
   virtual HostFunctionType& getHostFunction(const jsi::Function&) = 0;
 
+#if JSI_VERSION >= 7
   virtual bool hasNativeState(const jsi::Object&) = 0;
   virtual std::shared_ptr<NativeState> getNativeState(const jsi::Object&) = 0;
   virtual void setNativeState(
       const jsi::Object&,
       std::shared_ptr<NativeState> state) = 0;
+#endif
 
   virtual Value getProperty(const Object&, const PropNameID& name) = 0;
   virtual Value getProperty(const Object&, const String& name) = 0;
   virtual bool hasProperty(const Object&, const PropNameID& name) = 0;
   virtual bool hasProperty(const Object&, const String& name) = 0;
   virtual void setPropertyValue(
-      const Object&,
+      JSI_CONST_10 Object&,
       const PropNameID& name,
       const Value& value) = 0;
-  virtual void
-  setPropertyValue(const Object&, const String& name, const Value& value) = 0;
+  virtual void setPropertyValue(
+      JSI_CONST_10 Object&,
+      const String& name,
+      const Value& value) = 0;
 
   virtual bool isArray(const Object&) const = 0;
   virtual bool isArrayBuffer(const Object&) const = 0;
@@ -351,17 +391,19 @@ class JSI_EXPORT Runtime {
   virtual Array getPropertyNames(const Object&) = 0;
 
   virtual WeakObject createWeakObject(const Object&) = 0;
-  virtual Value lockWeakObject(const WeakObject&) = 0;
+  virtual Value lockWeakObject(JSI_NO_CONST_3 JSI_CONST_10 WeakObject&) = 0;
 
   virtual Array createArray(size_t length) = 0;
+#if JSI_VERSION >= 9
   virtual ArrayBuffer createArrayBuffer(
       std::shared_ptr<MutableBuffer> buffer) = 0;
+#endif
   virtual size_t size(const Array&) = 0;
   virtual size_t size(const ArrayBuffer&) = 0;
   virtual uint8_t* data(const ArrayBuffer&) = 0;
   virtual Value getValueAtIndex(const Array&, size_t i) = 0;
   virtual void
-  setValueAtIndexImpl(const Array&, size_t i, const Value& value) = 0;
+  setValueAtIndexImpl(JSI_CONST_10 Array&, size_t i, const Value& value) = 0;
 
   virtual Function createFunctionFromHostFunction(
       const PropNameID& name,
@@ -381,7 +423,9 @@ class JSI_EXPORT Runtime {
   virtual void popScope(ScopeState*);
 
   virtual bool strictEquals(const Symbol& a, const Symbol& b) const = 0;
+#if JSI_VERSION >= 6
   virtual bool strictEquals(const BigInt& a, const BigInt& b) const = 0;
+#endif
   virtual bool strictEquals(const String& a, const String& b) const = 0;
   virtual bool strictEquals(const Object& a, const Object& b) const = 0;
 
@@ -391,7 +435,9 @@ class JSI_EXPORT Runtime {
   // Value, Symbol, String, and Object, which are all friends of Runtime.
   template <typename T>
   static T make(PointerValue* pv);
+#if JSI_VERSION >= 3
   static PointerValue* getPointerValue(Pointer& pointer);
+#endif
   static const PointerValue* getPointerValue(const Pointer& pointer);
   static const PointerValue* getPointerValue(const Value& value);
 
@@ -471,10 +517,12 @@ class JSI_EXPORT PropNameID : public Pointer {
     return runtime.createPropNameIDFromString(str);
   }
 
+#if JSI_VERSION >= 5
   /// Create a PropNameID from a JS symbol.
   static PropNameID forSymbol(Runtime& runtime, const jsi::Symbol& sym) {
     return runtime.createPropNameIDFromSymbol(sym);
   }
+#endif
 
   // Creates a vector of PropNameIDs constructed from given arguments.
   template <typename... Args>
@@ -482,7 +530,7 @@ class JSI_EXPORT PropNameID : public Pointer {
 
   // Creates a vector of given PropNameIDs.
   template <size_t N>
-  static std::vector<PropNameID> names(PropNameID(&&propertyNames)[N]);
+  static std::vector<PropNameID> names(PropNameID (&&propertyNames)[N]);
 
   /// Copies the data in a PropNameID as utf8 into a C++ string.
   std::string utf8(Runtime& runtime) const {
@@ -527,6 +575,7 @@ class JSI_EXPORT Symbol : public Pointer {
   friend class Value;
 };
 
+#if JSI_VERSION >= 6
 /// Represents a JS BigInt.  Movable, not copyable.
 class JSI_EXPORT BigInt : public Pointer {
  public:
@@ -535,6 +584,7 @@ class JSI_EXPORT BigInt : public Pointer {
   BigInt(BigInt&& other) = default;
   BigInt& operator=(BigInt&& other) = default;
 
+#if JSI_VERSION >= 8
   /// Create a BigInt representing the signed 64-bit \p value.
   static BigInt fromInt64(Runtime& runtime, int64_t value) {
     return runtime.createBigIntFromInt64(value);
@@ -581,10 +631,12 @@ class JSI_EXPORT BigInt : public Pointer {
   /// \returns this BigInt converted to a String in base \p radix. Throws a
   /// JSIException if radix is not in the [2, 36] range.
   inline String toString(Runtime& runtime, int radix = 10) const;
+#endif
 
   friend class Runtime;
   friend class Value;
 };
+#endif
 
 /// Represents a JS String.  Movable, not copyable.
 class JSI_EXPORT String : public Pointer {
@@ -669,7 +721,7 @@ class JSI_EXPORT Object : public Pointer {
   }
 
   /// \return the result of `this instanceOf ctor` in JS.
-  bool instanceOf(Runtime& rt, const Function& ctor) const {
+  bool instanceOf(Runtime& rt, const Function& ctor) JSI_CONST_10 {
     return rt.instanceOf(*this, ctor);
   }
 
@@ -704,19 +756,21 @@ class JSI_EXPORT Object : public Pointer {
   /// used to make one: nullptr_t, bool, double, int, const char*,
   /// String, or Object.
   template <typename T>
-  void setProperty(Runtime& runtime, const char* name, T&& value) const;
+  void setProperty(Runtime& runtime, const char* name, T&& value) JSI_CONST_10;
 
   /// Sets the property value from a Value or anything which can be
   /// used to make one: nullptr_t, bool, double, int, const char*,
   /// String, or Object.
   template <typename T>
-  void setProperty(Runtime& runtime, const String& name, T&& value) const;
+  void setProperty(Runtime& runtime, const String& name, T&& value)
+      JSI_CONST_10;
 
   /// Sets the property value from a Value or anything which can be
   /// used to make one: nullptr_t, bool, double, int, const char*,
   /// String, or Object.
   template <typename T>
-  void setProperty(Runtime& runtime, const PropNameID& name, T&& value) const;
+  void setProperty(Runtime& runtime, const PropNameID& name, T&& value)
+      JSI_CONST_10;
 
   /// \return true iff JS \c Array.isArray() would return \c true.  If
   /// so, then \c getArray() will succeed.
@@ -799,6 +853,7 @@ class JSI_EXPORT Object : public Pointer {
   template <typename T = HostObject>
   std::shared_ptr<T> asHostObject(Runtime& runtime) const;
 
+#if JSI_VERSION >= 7
   /// \return whether this object has native state of type T previously set by
   /// \c setNativeState.
   template <typename T = NativeState>
@@ -817,6 +872,7 @@ class JSI_EXPORT Object : public Pointer {
   /// Throws a type error if this object is a proxy or host object.
   void setNativeState(Runtime& runtime, std::shared_ptr<NativeState> state)
       const;
+#endif
 
   /// \return same as \c getProperty(name).asObject(), except with
   /// a better exception message.
@@ -838,14 +894,14 @@ class JSI_EXPORT Object : public Pointer {
   void setPropertyValue(
       Runtime& runtime,
       const String& name,
-      const Value& value) const {
+      const Value& value) JSI_CONST_10 {
     return runtime.setPropertyValue(*this, name, value);
   }
 
   void setPropertyValue(
       Runtime& runtime,
       const PropNameID& name,
-      const Value& value) const {
+      const Value& value) JSI_CONST_10 {
     return runtime.setPropertyValue(*this, name, value);
   }
 
@@ -871,7 +927,7 @@ class JSI_EXPORT WeakObject : public Pointer {
   /// otherwise returns \c undefined.  Note that this method has nothing to do
   /// with threads or concurrency.  The name is based on std::weak_ptr::lock()
   /// which serves a similar purpose.
-  Value lock(Runtime& runtime) const;
+  Value lock(Runtime& runtime) JSI_CONST_10;
 
   friend class Runtime;
 };
@@ -907,7 +963,7 @@ class JSI_EXPORT Array : public Object {
   /// value behaves as with Object::setProperty().  If \c i is out of
   /// range [ 0..\c length ] throws a JSIException.
   template <typename T>
-  void setValueAtIndex(Runtime& runtime, size_t i, T&& value) const;
+  void setValueAtIndex(Runtime& runtime, size_t i, T&& value) JSI_CONST_10;
 
   /// There is no current API for changing the size of an array once
   /// created.  We'll probably need that eventually.
@@ -924,10 +980,9 @@ class JSI_EXPORT Array : public Object {
  private:
   friend class Object;
   friend class Value;
-  friend class Runtime;
 
   void setValueAtIndexImpl(Runtime& runtime, size_t i, const Value& value)
-      const {
+      JSI_CONST_10 {
     return runtime.setValueAtIndexImpl(*this, i, value);
   }
 
@@ -940,11 +995,12 @@ class JSI_EXPORT ArrayBuffer : public Object {
   ArrayBuffer(ArrayBuffer&&) = default;
   ArrayBuffer& operator=(ArrayBuffer&&) = default;
 
+#if JSI_VERSION >= 9
   ArrayBuffer(Runtime& runtime, std::shared_ptr<MutableBuffer> buffer)
       : ArrayBuffer(runtime.createArrayBuffer(std::move(buffer))) {}
+#endif
 
-  /// \return the size of the ArrayBuffer storage. This is not affected by
-  /// overriding the byteLength property.
+  /// \return the size of the ArrayBuffer, according to its byteLength property.
   /// (C++ naming convention)
   size_t size(Runtime& runtime) const {
     return runtime.size(*this);
@@ -954,14 +1010,13 @@ class JSI_EXPORT ArrayBuffer : public Object {
     return runtime.size(*this);
   }
 
-  uint8_t* data(Runtime& runtime) const {
+  uint8_t* data(Runtime& runtime) JSI_CONST_10 {
     return runtime.data(*this);
   }
 
  private:
   friend class Object;
   friend class Value;
-  friend class Runtime;
 
   ArrayBuffer(Runtime::PointerValue* value) : Object(value) {}
 };
@@ -1070,7 +1125,6 @@ class JSI_EXPORT Function : public Object {
  private:
   friend class Object;
   friend class Value;
-  friend class Runtime;
 
   Function(Runtime::PointerValue* value) : Object(value) {}
 };
@@ -1102,14 +1156,16 @@ class JSI_EXPORT Value {
   }
 
   /// Moves a Symbol, String, or Object rvalue into a new JS value.
-  template <
-      typename T,
-      typename = std::enable_if_t<
-          std::is_base_of<Symbol, T>::value ||
-          std::is_base_of<BigInt, T>::value ||
-          std::is_base_of<String, T>::value ||
-          std::is_base_of<Object, T>::value>>
+  template <typename T>
   /* implicit */ Value(T&& other) : Value(kindOf(other)) {
+    static_assert(
+        std::is_base_of<Symbol, T>::value ||
+#if JSI_VERSION >= 6
+            std::is_base_of<BigInt, T>::value ||
+#endif
+            std::is_base_of<String, T>::value ||
+            std::is_base_of<Object, T>::value,
+        "Value cannot be implicitly move-constructed from this type");
     new (&data_.pointer) T(std::move(other));
   }
 
@@ -1129,10 +1185,12 @@ class JSI_EXPORT Value {
     new (&data_.pointer) Symbol(runtime.cloneSymbol(sym.ptr_));
   }
 
+#if JSI_VERSION >= 6
   /// Copies a BigInt lvalue into a new JS value.
   Value(Runtime& runtime, const BigInt& bigint) : Value(BigIntKind) {
     new (&data_.pointer) BigInt(runtime.cloneBigInt(bigint.ptr_));
   }
+#endif
 
   /// Copies a String lvalue into a new JS value.
   Value(Runtime& runtime, const String& str) : Value(StringKind) {
@@ -1169,9 +1227,14 @@ class JSI_EXPORT Value {
 
   // \return a \c Value created from a utf8-encoded JSON string.
   static Value
-  createFromJsonUtf8(Runtime& runtime, const uint8_t* json, size_t length) {
+  createFromJsonUtf8(Runtime& runtime, const uint8_t* json, size_t length)
+#if JSI_VERSION >= 2
+  {
     return runtime.createValueFromJsonUtf8(json, length);
   }
+#else
+      ;
+#endif
 
   /// \return according to the Strict Equality Comparison algorithm, see:
   /// https://262.ecma-international.org/11.0/#sec-strict-equality-comparison
@@ -1203,9 +1266,11 @@ class JSI_EXPORT Value {
     return kind_ == StringKind;
   }
 
+#if JSI_VERSION >= 6
   bool isBigInt() const {
     return kind_ == BigIntKind;
   }
+#endif
 
   bool isSymbol() const {
     return kind_ == SymbolKind;
@@ -1255,6 +1320,7 @@ class JSI_EXPORT Value {
   Symbol asSymbol(Runtime& runtime) const&;
   Symbol asSymbol(Runtime& runtime) &&;
 
+#if JSI_VERSION >= 6
   /// \return the BigInt value, or asserts if not a bigint.
   BigInt getBigInt(Runtime& runtime) const& {
     assert(isBigInt());
@@ -1274,6 +1340,7 @@ class JSI_EXPORT Value {
   /// bigint
   BigInt asBigInt(Runtime& runtime) const&;
   BigInt asBigInt(Runtime& runtime) &&;
+#endif
 
   /// \return the String value, or asserts if not a string.
   String getString(Runtime& runtime) const& {
@@ -1327,7 +1394,9 @@ class JSI_EXPORT Value {
     BooleanKind,
     NumberKind,
     SymbolKind,
+#if JSI_VERSION >= 6
     BigIntKind,
+#endif
     StringKind,
     ObjectKind,
     PointerKind = SymbolKind,
@@ -1354,9 +1423,11 @@ class JSI_EXPORT Value {
   constexpr static ValueKind kindOf(const Symbol&) {
     return SymbolKind;
   }
+#if JSI_VERSION >= 6
   constexpr static ValueKind kindOf(const BigInt&) {
     return BigIntKind;
   }
+#endif
   constexpr static ValueKind kindOf(const String&) {
     return StringKind;
   }
@@ -1393,7 +1464,7 @@ class JSI_EXPORT Scope {
   explicit Scope(Runtime& rt) : rt_(rt), prv_(rt.pushScope()) {}
   ~Scope() {
     rt_.popScope(prv_);
-  }
+  };
 
   Scope(const Scope&) = delete;
   Scope(Scope&&) = delete;
@@ -1415,8 +1486,8 @@ class JSI_EXPORT Scope {
 /// Base class for jsi exceptions
 class JSI_EXPORT JSIException : public std::exception {
  protected:
-  JSIException() {}
-  JSIException(std::string what) : what_(std::move(what)) {}
+  JSIException(){};
+  JSIException(std::string what) : what_(std::move(what)){};
 
  public:
   JSIException(const JSIException&) = default;
@@ -1457,7 +1528,7 @@ class JSI_EXPORT JSError : public JSIException {
   /// Creates a JSError referring to new \c Error instance capturing current
   /// JavaScript stack. The error message property is set to given \c message.
   JSError(Runtime& rt, const char* message)
-      : JSError(rt, std::string(message)) {}
+      : JSError(rt, std::string(message)){};
 
   /// Creates a JSError referring to a JavaScript Object having message and
   /// stack properties set to provided values.
@@ -1468,11 +1539,6 @@ class JSI_EXPORT JSError : public JSIException {
   /// but necessary to avoid ambiguity with the above.
   JSError(std::string what, Runtime& rt, Value&& value);
 
-  /// Creates a JSError referring to the provided value, message and stack. This
-  /// constructor does not take a Runtime parameter, and therefore cannot result
-  /// in recursively invoking the JSError constructor.
-  JSError(Value&& value, std::string message, std::string stack);
-
   JSError(const JSError&) = default;
 
   virtual ~JSError();
@@ -1490,6 +1556,14 @@ class JSI_EXPORT JSError : public JSIException {
     return *value_;
   }
 
+  // In V8's case, creating an Error object in JS doesn't record the callstack.
+  // To preserve it, we need a way to manually add the stack here and on the JS
+  // side.
+  void setStack(std::string stack) {
+    stack_ = std::move(stack);
+    what_ = message_ + "\n\n" + stack_;
+  }
+
  private:
   // This initializes the value_ member and does some other
   // validation, so it must be called by every branch through the
diff --git a/node_modules/react-native/ReactCommon/jsi/jsi/test/testlib.cpp b/node_modules/react-native/ReactCommon/jsi/jsi/test/testlib.cpp
index bbfe8f2..0e4556c 100644
--- a/node_modules/react-native/ReactCommon/jsi/jsi/test/testlib.cpp
+++ b/node_modules/react-native/ReactCommon/jsi/jsi/test/testlib.cpp
@@ -1440,7 +1440,7 @@ TEST_P(JSITest, MultilevelDecoratedHostObject) {
   EXPECT_EQ(1, RD2::numGets);
 }
 
-TEST_P(JSITest, ArrayBufferSizeTest) {
+/*TEST_P(JSITest, ArrayBufferSizeTest) {
   auto ab =
       eval("var x = new ArrayBuffer(10); x").getObject(rt).getArrayBuffer(rt);
   EXPECT_EQ(ab.size(rt), 10);
@@ -1450,7 +1450,7 @@ TEST_P(JSITest, ArrayBufferSizeTest) {
   // Ensure that setting the byteLength property does not change the length.
   eval("Object.defineProperty(x, 'byteLength', {value: 20})");
   EXPECT_EQ(ab.size(rt), 10);
-}
+}*/
 
 INSTANTIATE_TEST_CASE_P(
     Runtimes,
diff --git a/node_modules/react-native/ReactCommon/jsi/jsi/test/testlib_ext.cpp b/node_modules/react-native/ReactCommon/jsi/jsi/test/testlib_ext.cpp
new file mode 100644
index 0000000..9cd12c2
--- /dev/null
+++ b/node_modules/react-native/ReactCommon/jsi/jsi/test/testlib_ext.cpp
@@ -0,0 +1,462 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+// These tests are adopted from the Hermes API tests
+
+#include <jsi/test/testlib.h>
+
+#include <gtest/gtest.h>
+#include <jsi/decorator.h>
+#include <jsi/jsi.h>
+
+#include <array>
+#include <chrono>
+#include <cstdlib>
+#include <functional>
+#include <thread>
+#include <unordered_map>
+#include <unordered_set>
+
+using namespace facebook::jsi;
+
+class JSITestExt : public JSITestBase {};
+
+// TODO: figure out how to fix it for V8
+#if 0
+TEST_P(JSITestExt, StrictHostFunctionBindTest) {
+  Function coolify = Function::createFromHostFunction(
+      rt,
+      PropNameID::forAscii(rt, "coolify"),
+      0,
+      [](Runtime&, const Value& thisVal, const Value* args, size_t count) {
+        EXPECT_TRUE(thisVal.isUndefined());
+        return thisVal.isUndefined();
+      });
+  rt.global().setProperty(rt, "coolify", coolify);
+  EXPECT_TRUE(eval("(function() {"
+                   "  \"use strict\";"
+                   "  return coolify.bind(undefined)();"
+                   "})()")
+                  .getBool());
+}
+#endif
+
+TEST_P(JSITestExt, DescriptionTest) {
+  // Description is not empty
+  EXPECT_NE(rt.description().size(), 0);
+}
+
+TEST_P(JSITestExt, ArrayBufferTest) {
+  eval(
+      "var buffer = new ArrayBuffer(16);\
+        var int32View = new Int32Array(buffer);\
+        int32View[0] = 1234;\
+        int32View[1] = 5678;");
+
+  Object object = rt.global().getPropertyAsObject(rt, "buffer");
+  EXPECT_TRUE(object.isArrayBuffer(rt));
+
+  auto arrayBuffer = object.getArrayBuffer(rt);
+  EXPECT_EQ(arrayBuffer.size(rt), 16);
+
+  int32_t* buffer = reinterpret_cast<int32_t*>(arrayBuffer.data(rt));
+  EXPECT_EQ(buffer[0], 1234);
+  EXPECT_EQ(buffer[1], 5678);
+}
+
+#if JSI_VERSION >= 9
+#ifndef JSI_V8_IMPL
+TEST_P(JSITestExt, ExternalArrayBufferTest) {
+  struct FixedBuffer : MutableBuffer {
+    size_t size() const override {
+      return sizeof(arr);
+    }
+    uint8_t* data() override {
+      return reinterpret_cast<uint8_t*>(arr.data());
+    }
+
+    std::array<uint32_t, 256> arr;
+  };
+
+  {
+    auto buf = std::make_shared<FixedBuffer>();
+    for (uint32_t i = 0; i < buf->arr.size(); i++)
+      buf->arr[i] = i;
+    auto arrayBuffer = ArrayBuffer(rt, buf);
+    auto square = eval(
+        R"#(
+(function (buf) {
+  var view = new Uint32Array(buf);
+  for(var i = 0; i < view.length; i++) view[i] = view[i] * view[i];
+})
+)#");
+    square.asObject(rt).asFunction(rt).call(rt, arrayBuffer);
+    for (uint32_t i = 0; i < 256; i++)
+      EXPECT_EQ(buf->arr[i], i * i);
+  }
+}
+#endif
+
+TEST_P(JSITestExt, NoCorruptionOnJSError) {
+  // If the test crashes or infinite loops, the likely cause is that
+  // Hermes API library is not built with proper compiler flags
+  // (-fexception in GCC/CLANG, /EHsc in MSVC)
+  try {
+    rt.evaluateJavaScript(std::make_unique<StringBuffer>("foo.bar = 1"), "");
+    FAIL() << "Expected JSIException";
+  } catch (const facebook::jsi::JSIException&) {
+    // expected exception, ignore
+  }
+  try {
+    rt.evaluateJavaScript(std::make_unique<StringBuffer>("foo.baz = 1"), "");
+    FAIL() << "Expected JSIException";
+  } catch (const facebook::jsi::JSIException&) {
+    // expected exception, ignore
+  }
+  rt.evaluateJavaScript(std::make_unique<StringBuffer>("gc()"), "");
+}
+
+#if !defined(JSI_V8_IMPL)
+TEST_P(JSITestExt, SpreadHostObjectWithOwnProperties) {
+  class HostObjectWithPropertyNames : public HostObject {
+    std::vector<PropNameID> getPropertyNames(Runtime& rt) override {
+      return PropNameID::names(rt, "prop1", "1", "2", "prop2", "3");
+    }
+    Value get(Runtime& runtime, const PropNameID& name) override {
+      return Value();
+    }
+  };
+
+  Object ho = Object::createFromHostObject(
+      rt, std::make_shared<HostObjectWithPropertyNames>());
+  rt.global().setProperty(rt, "ho", ho);
+
+  auto res = eval(R"###(
+var spreaded = {...ho};
+var props = Object.getOwnPropertyNames(spreaded);
+props.toString();
+)###")
+                 .getString(rt)
+                 .utf8(rt);
+  EXPECT_EQ(res, "1,2,3,prop1,prop2");
+}
+
+TEST_P(JSITestExt, HostObjectWithOwnProperties) {
+  class HostObjectWithPropertyNames : public HostObject {
+    std::vector<PropNameID> getPropertyNames(Runtime& rt) override {
+      return PropNameID::names(rt, "prop1", "1", "2", "prop2", "3");
+    }
+    Value get(Runtime& runtime, const PropNameID& name) override {
+      if (PropNameID::compare(
+              runtime, name, PropNameID::forAscii(runtime, "prop1")))
+        return 10;
+      return Value();
+    }
+  };
+
+  Object ho = Object::createFromHostObject(
+      rt, std::make_shared<HostObjectWithPropertyNames>());
+  rt.global().setProperty(rt, "ho", ho);
+
+  EXPECT_TRUE(eval("\"prop1\" in ho").getBool());
+  EXPECT_TRUE(eval("1 in ho").getBool());
+  EXPECT_TRUE(eval("2 in ho").getBool());
+  EXPECT_TRUE(eval("\"prop2\" in ho").getBool());
+  EXPECT_TRUE(eval("3 in ho").getBool());
+  // HostObjects say they own any property, even if it's not in their property
+  // names list.
+  // This is an explicit design choice, to avoid the runtime and API costs of
+  // handling checking for property existence.
+  EXPECT_TRUE(eval("\"foo\" in ho").getBool());
+
+  EXPECT_TRUE(eval("var properties = Object.getOwnPropertyNames(ho);"
+                   "properties[0] === '1' && "
+                   "properties[1] === '2' && "
+                   "properties[2] === '3' && "
+                   "properties[3] === 'prop1' && "
+                   "properties[4] === 'prop2' && "
+                   "properties.length === 5")
+                  .getBool());
+  EXPECT_TRUE(eval("ho[2] === undefined").getBool());
+  EXPECT_TRUE(eval("ho.prop2 === undefined").getBool());
+
+  eval("Object.defineProperty(ho, '0', {value: 'hi there'})");
+  eval("Object.defineProperty(ho, '2', {value: 'hi there'})");
+  eval("Object.defineProperty(ho, '4', {value: 'hi there'})");
+  eval("Object.defineProperty(ho, 'prop2', {value: 'hi there'})");
+
+  EXPECT_TRUE(eval("var properties = Object.getOwnPropertyNames(ho);"
+                   "properties[0] === '0' && "
+                   "properties[1] === '1' && "
+                   "properties[2] === '2' && "
+                   "properties[3] === '3' && "
+                   "properties[4] === '4' && "
+                   "properties[5] === 'prop2' && "
+                   "properties[6] === 'prop1' && "
+                   "properties.length === 7")
+                  .getBool());
+  EXPECT_TRUE(eval("ho[2] === 'hi there'").getBool());
+  EXPECT_TRUE(eval("ho.prop2 === 'hi there'").getBool());
+
+  // hasOwnProperty() always succeeds on HostObject
+  EXPECT_TRUE(
+      eval("Object.prototype.hasOwnProperty.call(ho, 'prop1')").getBool());
+  EXPECT_TRUE(
+      eval("Object.prototype.hasOwnProperty.call(ho, 'any-string')").getBool());
+
+  // getOwnPropertyDescriptor() always succeeds on HostObject
+  EXPECT_TRUE(eval("var d = Object.getOwnPropertyDescriptor(ho, 'prop1');"
+                   "d != undefined && "
+                   "d.value == 10 && "
+                   "d.enumerable && "
+                   "d.writable ")
+                  .getBool());
+  EXPECT_TRUE(eval("var d = Object.getOwnPropertyDescriptor(ho, 'any-string');"
+                   "d != undefined && "
+                   "d.value == undefined && "
+                   "d.enumerable && "
+                   "d.writable")
+                  .getBool());
+}
+#endif
+
+TEST_P(JSITestExt, HostObjectAsParentTest) {
+  class HostObjectWithProp : public HostObject {
+    Value get(Runtime& runtime, const PropNameID& name) override {
+      if (PropNameID::compare(
+              runtime, name, PropNameID::forAscii(runtime, "prop1")))
+        return 10;
+      return Value();
+    }
+  };
+
+  Object ho =
+      Object::createFromHostObject(rt, std::make_shared<HostObjectWithProp>());
+  rt.global().setProperty(rt, "ho", ho);
+
+  EXPECT_TRUE(
+      eval("var subClass = {__proto__: ho}; subClass.prop1 == 10;").getBool());
+}
+
+#if JSI_VERSION >= 5
+TEST_P(JSITestExt, PropNameIDFromSymbol) {
+  auto strProp = PropNameID::forAscii(rt, "a");
+  auto secretProp = PropNameID::forSymbol(
+      rt, eval("var secret = Symbol('a'); secret;").getSymbol(rt));
+  auto globalProp =
+      PropNameID::forSymbol(rt, eval("Symbol.for('a');").getSymbol(rt));
+  auto x =
+      eval("({a : 'str', [secret] : 'secret', [Symbol.for('a')] : 'global'});")
+          .getObject(rt);
+
+  EXPECT_EQ(x.getProperty(rt, strProp).getString(rt).utf8(rt), "str");
+  EXPECT_EQ(x.getProperty(rt, secretProp).getString(rt).utf8(rt), "secret");
+  EXPECT_EQ(x.getProperty(rt, globalProp).getString(rt).utf8(rt), "global");
+}
+#endif
+
+TEST_P(JSITestExt, HasComputedTest) {
+  // The only use of JSObject::hasComputed() is in HermesRuntimeImpl,
+  // so we test its Proxy support here, instead of from JS.
+
+  EXPECT_FALSE(eval("'prop' in new Proxy({}, {})").getBool());
+  EXPECT_TRUE(eval("'prop' in new Proxy({prop:1}, {})").getBool());
+  EXPECT_FALSE(
+      eval("'prop' in new Proxy({}, {has() { return false; }})").getBool());
+  EXPECT_TRUE(
+      eval("'prop' in new Proxy({}, {has() { return true; }})").getBool());
+
+  // While we're here, test that a HostFunction can be used as a proxy
+  // trap.  This could be very powerful in the right hands.
+  Function returnTrue = Function::createFromHostFunction(
+      rt,
+      PropNameID::forAscii(rt, "returnTrue"),
+      0,
+      [](Runtime& rt, const Value&, const Value* args, size_t count) {
+        EXPECT_EQ(count, 2);
+        EXPECT_EQ(args[1].toString(rt).utf8(rt), "prop");
+        return true;
+      });
+  rt.global().setProperty(rt, "returnTrue", returnTrue);
+  EXPECT_TRUE(eval("'prop' in new Proxy({}, {has: returnTrue})").getBool());
+}
+
+TEST_P(JSITestExt, GlobalObjectTest) {
+  rt.global().setProperty(rt, "a", 5);
+  eval("f = function(b) { return a + b; }");
+  eval("gc()");
+  EXPECT_EQ(eval("f(10)").getNumber(), 15);
+}
+#endif
+
+#if JSI_VERSION >= 8
+#if !defined(JSI_V8_IMPL)
+TEST_P(JSITestExt, BigIntJSI) {
+  Function bigintCtor = rt.global().getPropertyAsFunction(rt, "BigInt");
+  auto BigInt = [&](const char* v) { return bigintCtor.call(rt, eval(v)); };
+
+  auto v0 = BigInt("0");
+  auto b0 = v0.asBigInt(rt);
+  EXPECT_EQ(v0.toString(rt).utf8(rt), "0");
+  EXPECT_EQ(b0.toString(rt).utf8(rt), "0");
+
+  auto vffffffffffffffff = BigInt("0xffffffffffffffffn");
+  auto bffffffffffffffff = vffffffffffffffff.asBigInt(rt);
+  EXPECT_EQ(vffffffffffffffff.toString(rt).utf8(rt), "18446744073709551615");
+  EXPECT_EQ(bffffffffffffffff.toString(rt, 16).utf8(rt), "ffffffffffffffff");
+  EXPECT_EQ(bffffffffffffffff.toString(rt, 36).utf8(rt), "3w5e11264sgsf");
+
+  auto vNeg1 = BigInt("-1");
+  auto bNeg1 = vNeg1.asBigInt(rt);
+  EXPECT_EQ(vNeg1.toString(rt).utf8(rt), "-1");
+  EXPECT_EQ(bNeg1.toString(rt, 16).utf8(rt), "-1");
+  EXPECT_EQ(bNeg1.toString(rt, 36).utf8(rt), "-1");
+
+  EXPECT_TRUE(BigInt::strictEquals(rt, b0, b0));
+  EXPECT_TRUE(BigInt::strictEquals(rt, bffffffffffffffff, bffffffffffffffff));
+  EXPECT_FALSE(BigInt::strictEquals(rt, bNeg1, bffffffffffffffff));
+}
+
+TEST_P(JSITestExt, BigIntJSIFromScalar) {
+  Function bigintCtor = rt.global().getPropertyAsFunction(rt, "BigInt");
+  auto BigInt = [&](const char* v) {
+    return bigintCtor.call(rt, eval(v)).asBigInt(rt);
+  };
+
+  EXPECT_TRUE(BigInt::strictEquals(rt, BigInt("0"), BigInt::fromUint64(rt, 0)));
+  EXPECT_TRUE(BigInt::strictEquals(rt, BigInt("0"), BigInt::fromInt64(rt, 0)));
+  EXPECT_TRUE(BigInt::strictEquals(
+      rt, BigInt("0xdeadbeef"), BigInt::fromUint64(rt, 0xdeadbeef)));
+  EXPECT_TRUE(BigInt::strictEquals(
+      rt, BigInt("0xc0ffee"), BigInt::fromInt64(rt, 0xc0ffee)));
+  EXPECT_TRUE(BigInt::strictEquals(
+      rt, BigInt("0xffffffffffffffffn"), BigInt::fromUint64(rt, ~0ull)));
+  EXPECT_TRUE(
+      BigInt::strictEquals(rt, BigInt("-1"), BigInt::fromInt64(rt, ~0ull)));
+}
+
+TEST_P(JSITestExt, BigIntJSIToString) {
+  auto b = BigInt::fromUint64(rt, 1);
+  // Test all possible radixes.
+  for (int radix = 2; radix <= 36; ++radix) {
+    EXPECT_EQ(b.toString(rt, radix).utf8(rt), "1") << radix;
+  }
+
+  // Test some invaild radixes.
+  EXPECT_THROW(b.toString(rt, -1), JSIException);
+  EXPECT_THROW(b.toString(rt, 0), JSIException);
+  EXPECT_THROW(b.toString(rt, 1), JSIException);
+  EXPECT_THROW(b.toString(rt, 37), JSIException);
+  EXPECT_THROW(b.toString(rt, 100), JSIException);
+
+  Function bigintCtor = rt.global().getPropertyAsFunction(rt, "BigInt");
+  auto BigInt = [&](int value) {
+    return bigintCtor.call(rt, value).asBigInt(rt);
+  };
+
+  // Now test that the radix is being passed to the VM.
+  for (int radix = 2; radix <= 36; ++radix) {
+    EXPECT_EQ(BigInt(radix + 1).toString(rt, radix).utf8(rt), "11") << radix;
+    EXPECT_EQ(BigInt(-(radix + 1)).toString(rt, radix).utf8(rt), "-11")
+        << radix;
+  }
+}
+
+TEST_P(JSITestExt, BigIntJSITruncation) {
+  auto lossless = [](uint64_t value) { return std::make_tuple(value, true); };
+  auto lossy = [](uint64_t value) { return std::make_tuple(value, false); };
+
+  auto toInt64 = [this](const BigInt& b) {
+    return std::make_tuple(b.getInt64(rt), b.isInt64(rt));
+  };
+
+  auto toUint64 = [this](const BigInt& b) {
+    return std::make_tuple(b.getUint64(rt), b.isUint64(rt));
+  };
+
+  Function bigintCtor = rt.global().getPropertyAsFunction(rt, "BigInt");
+  auto BigInt = [&](const char* v) {
+    return bigintCtor.call(rt, eval(v)).asBigInt(rt);
+  };
+
+  // 0n can be truncated losslessly to either int64_t and uint64_t
+  auto b = BigInt::fromUint64(rt, 0);
+  EXPECT_EQ(toUint64(b), lossless(0));
+  EXPECT_TRUE(
+      BigInt::strictEquals(rt, BigInt::fromUint64(rt, b.getUint64(rt)), b));
+  EXPECT_EQ(toInt64(b), lossless(0));
+  EXPECT_TRUE(
+      BigInt::strictEquals(rt, BigInt::fromInt64(rt, b.getInt64(rt)), b));
+
+  // Creating BigInt from an ~0ull. This value can't be truncated losslessly to
+  // int64_t.
+  b = BigInt::fromUint64(rt, ~0ull);
+  EXPECT_EQ(toUint64(b), lossless(~0ull));
+  EXPECT_TRUE(
+      BigInt::strictEquals(rt, BigInt::fromUint64(rt, b.getUint64(rt)), b));
+  EXPECT_EQ(toInt64(b), lossy(~0ull));
+
+  // Creating BigInt from an -1ull. This value can't be truncated losslessly to
+  // int64_t.
+  b = BigInt::fromInt64(rt, -1ull);
+  EXPECT_EQ(toUint64(b), lossy(-1ull));
+  EXPECT_EQ(toInt64(b), lossless(-1ull));
+  EXPECT_TRUE(
+      BigInt::strictEquals(rt, BigInt::fromInt64(rt, b.getInt64(rt)), b));
+
+  // 0x10000000000000000n can't be truncated to int64_t nor uint64_t.
+  b = BigInt("0x10000000000000000n");
+  EXPECT_EQ(toUint64(b), lossy(0));
+  EXPECT_EQ(toInt64(b), lossy(0));
+
+  // -0x10000000000000000n can't be truncated to int64_t nor uint64_t.
+  b = BigInt("-0x10000000000000000n");
+  EXPECT_EQ(toUint64(b), lossy(0));
+  EXPECT_EQ(toInt64(b), lossy(0));
+
+  // (1n << 65n) - 1n can't be truncated to int64_t nor uint64_t.
+  b = BigInt("(1n << 65n) - 1n");
+  EXPECT_EQ(toUint64(b), lossy(~0ull));
+  EXPECT_EQ(toInt64(b), lossy(~0ull));
+}
+#endif
+#endif
+
+TEST_P(JSITestExt, NativeExceptionDoesNotUseGlobalError) {
+  Function alwaysThrows = Function::createFromHostFunction(
+      rt,
+      PropNameID::forAscii(rt, "alwaysThrows"),
+      0,
+      [](Runtime&, const Value&, const Value*, size_t) -> Value {
+        throw std::logic_error(
+            "Native std::logic_error C++ exception in Host Function");
+      });
+  rt.global().setProperty(rt, "alwaysThrows", alwaysThrows);
+  rt.global().setProperty(rt, "Error", 10);
+
+  auto test = eval(
+                  R"#((function(val) {
+                          'use strict';
+                          try {
+                            alwaysThrows(val);
+                          } catch(e) {
+                            return 'typeof Error is ' + typeof(Error) + '; ' + e.message;
+                          }
+                          throw new Error('Unreachable statement');
+                       }))#")
+                  .getObject(rt)
+                  .getFunction(rt);
+  EXPECT_EQ(
+      "typeof Error is number; Exception in HostFunction: Native "
+      "std::logic_error C++ exception in Host Function",
+      test.call(rt).getString(rt).utf8(rt));
+}
+
+INSTANTIATE_TEST_SUITE_P(
+    Runtimes,
+    JSITestExt,
+    ::testing::ValuesIn(runtimeGenerators()));
diff --git a/node_modules/react-native/ReactCommon/react/bridging/Bridging.h b/node_modules/react-native/ReactCommon/react/bridging/Bridging.h
index b8a0229..3f4222d 100644
--- a/node_modules/react-native/ReactCommon/react/bridging/Bridging.h
+++ b/node_modules/react-native/ReactCommon/react/bridging/Bridging.h
@@ -11,7 +11,7 @@
 #include <react/bridging/Array.h>
 #include <react/bridging/Bool.h>
 #include <react/bridging/Class.h>
-#include <react/bridging/Dynamic.h>
+// #include <react/bridging/Dynamic.h> // Line causes Error C1083 Cannot open include file: 'double-conversion/double-conversion.h' #11644
 #include <react/bridging/Error.h>
 #include <react/bridging/Function.h>
 #include <react/bridging/Number.h>
diff --git a/node_modules/react-native/ReactCommon/react/bridging/CallbackWrapper.h b/node_modules/react-native/ReactCommon/react/bridging/CallbackWrapper.h
index 9efa296..af9f8d1 100644
--- a/node_modules/react-native/ReactCommon/react/bridging/CallbackWrapper.h
+++ b/node_modules/react-native/ReactCommon/react/bridging/CallbackWrapper.h
@@ -8,58 +8,96 @@
 #pragma once
 
 #include <jsi/jsi.h>
-#include "LongLivedObject.h"
+#include <LongLivedObject.h>
 
 #include <memory>
 
-namespace facebook::react {
+namespace facebook {
+namespace react {
 
 // Helper for passing jsi::Function arg to other methods.
 class CallbackWrapper : public LongLivedObject {
  private:
   CallbackWrapper(
-      jsi::Function&& callback,
-      jsi::Runtime& runtime,
+      jsi::Function &&callback,
+      jsi::Runtime &runtime,
       std::shared_ptr<CallInvoker> jsInvoker)
-      : callback_(std::move(callback)),
+      : longLivedObjectCollection_(),
+        callback_(std::move(callback)),
         runtime_(runtime),
         jsInvoker_(std::move(jsInvoker)) {}
 
+  CallbackWrapper(
+      std::shared_ptr<LongLivedObjectCollection> longLivedObjectCollection,
+      jsi::Function &&callback,
+      jsi::Runtime &runtime,
+      std::shared_ptr<CallInvoker> jsInvoker)
+      : longLivedObjectCollection_(longLivedObjectCollection),
+        callback_(std::move(callback)),
+        runtime_(runtime),
+        jsInvoker_(std::move(jsInvoker)) {}
+
+  // Use a weak_ptr to avoid a retain cycle: LongLivedObjectCollection owns all
+  // CallbackWrappers. So, CallbackWrapper cannot own its
+  // LongLivedObjectCollection.
+  std::weak_ptr<LongLivedObjectCollection> longLivedObjectCollection_;
   jsi::Function callback_;
-  jsi::Runtime& runtime_;
+  jsi::Runtime &runtime_;
   std::shared_ptr<CallInvoker> jsInvoker_;
 
  public:
   static std::weak_ptr<CallbackWrapper> createWeak(
-      jsi::Function&& callback,
-      jsi::Runtime& runtime,
+      jsi::Function &&callback,
+      jsi::Runtime &runtime,
       std::shared_ptr<CallInvoker> jsInvoker) {
-    auto wrapper = std::shared_ptr<CallbackWrapper>(new CallbackWrapper(
-        std::move(callback), runtime, std::move(jsInvoker)));
+    auto wrapper = std::shared_ptr<CallbackWrapper>(
+        new CallbackWrapper(std::move(callback), runtime, jsInvoker));
     LongLivedObjectCollection::get().add(wrapper);
     return wrapper;
   }
 
+  static std::weak_ptr<CallbackWrapper> createWeak(
+      std::shared_ptr<LongLivedObjectCollection> longLivedObjectCollection,
+      jsi::Function &&callback,
+      jsi::Runtime &runtime,
+      std::shared_ptr<CallInvoker> jsInvoker) {
+    auto wrapper = std::shared_ptr<CallbackWrapper>(new CallbackWrapper(
+        longLivedObjectCollection, std::move(callback), runtime, jsInvoker));
+    longLivedObjectCollection->add(wrapper);
+    return wrapper;
+  }
+
   // Delete the enclosed jsi::Function
   void destroy() {
     allowRelease();
   }
 
-  jsi::Function& callback() {
+  jsi::Function &callback() {
     return callback_;
   }
 
-  jsi::Runtime& runtime() {
+  jsi::Runtime &runtime() {
     return runtime_;
   }
 
-  CallInvoker& jsInvoker() {
+  CallInvoker &jsInvoker() {
     return *(jsInvoker_);
   }
 
   std::shared_ptr<CallInvoker> jsInvokerPtr() {
     return jsInvoker_;
   }
+
+  void allowRelease() {
+    if (auto longLivedObjectCollection = longLivedObjectCollection_.lock()) {
+      if (longLivedObjectCollection != nullptr) {
+        longLivedObjectCollection->remove(this);
+        return;
+      }
+    }
+    LongLivedObject::allowRelease();
+  }
 };
 
-} // namespace facebook::react
+} // namespace react
+} // namespace facebook
diff --git a/node_modules/react-native/ReactCommon/react/bridging/LongLivedObject.cpp b/node_modules/react-native/ReactCommon/react/bridging/LongLivedObject.cpp
index 410f52d..40fa47b 100644
--- a/node_modules/react-native/ReactCommon/react/bridging/LongLivedObject.cpp
+++ b/node_modules/react-native/ReactCommon/react/bridging/LongLivedObject.cpp
@@ -5,45 +5,56 @@
  * LICENSE file in the root directory of this source tree.
  */
 
+// [Windows - see issue #11019, this file is an older version]
+
 #include "LongLivedObject.h"
 
-namespace facebook::react {
+namespace facebook {
+namespace react {
 
 // LongLivedObjectCollection
-LongLivedObjectCollection& LongLivedObjectCollection::get() {
+LongLivedObjectCollection &LongLivedObjectCollection::get() {
   static LongLivedObjectCollection instance;
   return instance;
 }
 
-void LongLivedObjectCollection::add(std::shared_ptr<LongLivedObject> so) {
-  std::scoped_lock lock(collectionMutex_);
-  collection_.insert(std::move(so));
+LongLivedObjectCollection::LongLivedObjectCollection() {}
+
+void LongLivedObjectCollection::add(std::shared_ptr<LongLivedObject> so) const {
+  std::lock_guard<std::mutex> lock(collectionMutex_);
+  collection_.insert(so);
 }
 
-void LongLivedObjectCollection::remove(const LongLivedObject* o) {
-  std::scoped_lock lock(collectionMutex_);
-  for (auto p = collection_.begin(); p != collection_.end(); p++) {
+void LongLivedObjectCollection::remove(const LongLivedObject *o) const {
+  std::lock_guard<std::mutex> lock(collectionMutex_);
+  auto p = collection_.begin();
+  for (; p != collection_.end(); p++) {
     if (p->get() == o) {
-      collection_.erase(p);
       break;
     }
   }
+  if (p != collection_.end()) {
+    collection_.erase(p);
+  }
 }
 
-void LongLivedObjectCollection::clear() {
-  std::scoped_lock lock(collectionMutex_);
+void LongLivedObjectCollection::clear() const {
+  std::lock_guard<std::mutex> lock(collectionMutex_);
   collection_.clear();
 }
 
 size_t LongLivedObjectCollection::size() const {
-  std::scoped_lock lock(collectionMutex_);
+  std::lock_guard<std::mutex> lock(collectionMutex_);
   return collection_.size();
 }
 
 // LongLivedObject
+LongLivedObject::LongLivedObject() {}
+LongLivedObject::~LongLivedObject() {}
 
 void LongLivedObject::allowRelease() {
   LongLivedObjectCollection::get().remove(this);
 }
 
-} // namespace facebook::react
+} // namespace react
+} // namespace facebook
\ No newline at end of file
diff --git a/node_modules/react-native/ReactCommon/react/bridging/LongLivedObject.h b/node_modules/react-native/ReactCommon/react/bridging/LongLivedObject.h
index 5b29c42..76d785c 100644
--- a/node_modules/react-native/ReactCommon/react/bridging/LongLivedObject.h
+++ b/node_modules/react-native/ReactCommon/react/bridging/LongLivedObject.h
@@ -5,13 +5,16 @@
  * LICENSE file in the root directory of this source tree.
  */
 
+// [Windows - see issue #11019, this file is an older version]
+
 #pragma once
 
 #include <memory>
 #include <mutex>
 #include <unordered_set>
 
-namespace facebook::react {
+namespace facebook {
+namespace react {
 
 /**
  * A simple wrapper class that can be registered to a collection that keep it
@@ -25,11 +28,11 @@ namespace facebook::react {
  */
 class LongLivedObject {
  public:
-  void allowRelease();
+  virtual void allowRelease();
 
  protected:
-  LongLivedObject() = default;
-  virtual ~LongLivedObject() = default;
+  LongLivedObject();
+  virtual ~LongLivedObject();
 };
 
 /**
@@ -37,21 +40,21 @@ class LongLivedObject {
  */
 class LongLivedObjectCollection {
  public:
-  static LongLivedObjectCollection& get();
+  static LongLivedObjectCollection &get();
 
-  LongLivedObjectCollection(const LongLivedObjectCollection&) = delete;
-  void operator=(const LongLivedObjectCollection&) = delete;
+  LongLivedObjectCollection();
+  LongLivedObjectCollection(LongLivedObjectCollection const &) = delete;
+  void operator=(LongLivedObjectCollection const &) = delete;
 
-  void add(std::shared_ptr<LongLivedObject> o);
-  void remove(const LongLivedObject* o);
-  void clear();
+  void add(std::shared_ptr<LongLivedObject> o) const;
+  void remove(const LongLivedObject *o) const;
+  void clear() const;
   size_t size() const;
 
  private:
-  LongLivedObjectCollection() = default;
-
-  std::unordered_set<std::shared_ptr<LongLivedObject>> collection_;
+  mutable std::unordered_set<std::shared_ptr<LongLivedObject>> collection_;
   mutable std::mutex collectionMutex_;
 };
 
-} // namespace facebook::react
+} // namespace react
+} // namespace facebook
\ No newline at end of file
diff --git a/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleBinding.cpp b/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleBinding.cpp
index b03715f..7d0f2e2 100644
--- a/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleBinding.cpp
+++ b/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleBinding.cpp
@@ -5,103 +5,33 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include "TurboModuleBinding.h"
+// [Windows - see issue #11019, this file is an older version]
 
+#include "TurboModuleBinding.h"
 #include <stdexcept>
 #include <string>
-
 #include <ReactCommon/LongLivedObject.h>
 #include <cxxreact/SystraceSection.h>
-
 using namespace facebook;
-
-namespace facebook::react {
-
-class BridgelessNativeModuleProxy : public jsi::HostObject {
-  std::unique_ptr<TurboModuleBinding> binding_;
-
- public:
-  BridgelessNativeModuleProxy(std::unique_ptr<TurboModuleBinding> binding)
-      : binding_(std::move(binding)) {}
-
-  jsi::Value get(jsi::Runtime& runtime, const jsi::PropNameID& name) override {
-    /**
-     * BatchedBridge/NativeModules.js contains this line:
-     *
-     * module.exports = global.nativeModuleProxy
-     *
-     * This means that NativeModuleProxy is exported as a module from
-     * 'NativeModules.js'. Whenever some JavaScript requires 'NativeModule.js',
-     * Metro checks this module's __esModule property to see if the module is an
-     * ES6 module.
-     *
-     * We return false from this property access, so that we can fail on the
-     * actual NativeModule require that happens later, which is more actionable.
-     */
-    std::string moduleName = name.utf8(runtime);
-    if (moduleName == "__esModule") {
-      return jsi::Value(false);
-    }
-
-    if (binding_) {
-      return binding_->getModule(runtime, moduleName);
-    }
-
-    throw jsi::JSError(
-        runtime,
-        "Tried to access NativeModule \"" + name.utf8(runtime) +
-            "\" from the bridge. This isn't allowed in Bridgeless mode.");
-  }
-
-  void set(
-      jsi::Runtime& runtime,
-      const jsi::PropNameID& /*name*/,
-      const jsi::Value& /*value*/) override {
-    throw jsi::JSError(
-        runtime,
-        "Tried to insert a NativeModule into the bridge's NativeModule proxy.");
-  }
-};
-
-// TODO(148359183): Merge this with the Bridgeless defineReadOnlyGlobal util
-static void defineReadOnlyGlobal(
-    jsi::Runtime& runtime,
-    std::string propName,
-    jsi::Value&& value) {
-  if (runtime.global().hasProperty(runtime, propName.c_str())) {
-    throw jsi::JSError(
-        runtime,
-        "Tried to redefine read-only global \"" + propName +
-            "\", but read-only globals can only be defined once.");
-  }
-  jsi::Object jsObject =
-      runtime.global().getProperty(runtime, "Object").asObject(runtime);
-  jsi::Function defineProperty = jsObject.getProperty(runtime, "defineProperty")
-                                     .asObject(runtime)
-                                     .asFunction(runtime);
-
-  jsi::Object descriptor = jsi::Object(runtime);
-  descriptor.setProperty(runtime, "value", std::move(value));
-  defineProperty.callWithThis(
-      runtime,
-      jsObject,
-      runtime.global(),
-      jsi::String::createFromUtf8(runtime, propName),
-      descriptor);
-}
-
+namespace facebook {
+namespace react {
 /**
  * Public API to install the TurboModule system.
  */
 
 TurboModuleBinding::TurboModuleBinding(
-    TurboModuleProviderFunctionType&& moduleProvider)
-    : moduleProvider_(std::move(moduleProvider)) {}
+    const TurboModuleProviderFunctionType &&moduleProvider,
+    TurboModuleBindingMode bindingMode,
+    std::shared_ptr<LongLivedObjectCollection> longLivedObjectCollection)
+    : moduleProvider_(std::move(moduleProvider)),
+      longLivedObjectCollection_(std::move(longLivedObjectCollection)),
+      bindingMode_(bindingMode) {}
 
 void TurboModuleBinding::install(
-    jsi::Runtime& runtime,
-    TurboModuleProviderFunctionType&& moduleProvider,
-    TurboModuleProviderFunctionType&& legacyModuleProvider) {
+    jsi::Runtime &runtime,
+    const TurboModuleProviderFunctionType &&moduleProvider,
+    TurboModuleBindingMode bindingMode,
+    std::shared_ptr<LongLivedObjectCollection> longLivedObjectCollection) {
   runtime.global().setProperty(
       runtime,
       "__turboModuleProxy",
@@ -109,47 +39,36 @@ void TurboModuleBinding::install(
           runtime,
           jsi::PropNameID::forAscii(runtime, "__turboModuleProxy"),
           1,
-          [binding = TurboModuleBinding(std::move(moduleProvider))](
-              jsi::Runtime& rt,
-              const jsi::Value& thisVal,
-              const jsi::Value* args,
-              size_t count) {
-            if (count < 1) {
-              throw std::invalid_argument(
-                  "__turboModuleProxy must be called with at least 1 argument");
-            }
-            std::string moduleName = args[0].getString(rt).utf8(rt);
-            return binding.getModule(rt, moduleName);
+          [binding = TurboModuleBinding(
+               std::move(moduleProvider),
+               bindingMode,
+               std::move(longLivedObjectCollection))](
+              jsi::Runtime &rt,
+              const jsi::Value &thisVal,
+              const jsi::Value *args,
+              size_t count) mutable {
+            return binding.getModule(rt, thisVal, args, count);
           }));
-
-  if (runtime.global().hasProperty(runtime, "RN$Bridgeless")) {
-    if (legacyModuleProvider != nullptr) {
-      defineReadOnlyGlobal(runtime, "RN$TurboInterop", jsi::Value(true));
-      defineReadOnlyGlobal(
-          runtime,
-          "nativeModuleProxy",
-          jsi::Object::createFromHostObject(
-              runtime,
-              std::make_shared<BridgelessNativeModuleProxy>(
-                  std::make_unique<TurboModuleBinding>(
-                      std::move(legacyModuleProvider)))));
-    } else {
-      defineReadOnlyGlobal(
-          runtime,
-          "nativeModuleProxy",
-          jsi::Object::createFromHostObject(
-              runtime, std::make_shared<BridgelessNativeModuleProxy>(nullptr)));
-    }
-  }
 }
 
 TurboModuleBinding::~TurboModuleBinding() {
-  LongLivedObjectCollection::get().clear();
+  if (longLivedObjectCollection_) {
+    longLivedObjectCollection_->clear();
+  } else {
+    LongLivedObjectCollection::get().clear();
+  }
 }
 
 jsi::Value TurboModuleBinding::getModule(
-    jsi::Runtime& runtime,
-    const std::string& moduleName) const {
+    jsi::Runtime &runtime,
+    const jsi::Value &thisVal,
+    const jsi::Value *args,
+    size_t count) {
+  if (count < 1) {
+    throw std::invalid_argument(
+        "__turboModuleProxy must be called with at least 1 argument");
+  }
+  std::string moduleName = args[0].getString(runtime).utf8(runtime);
   std::shared_ptr<TurboModule> module;
   {
     SystraceSection s(
@@ -157,14 +76,12 @@ jsi::Value TurboModuleBinding::getModule(
     module = moduleProvider_(moduleName);
   }
   if (module) {
-    // What is jsRepresentation? A cache for the TurboModule's properties
-    // Henceforth, always return the cache (i.e: jsRepresentation) to JavaScript
-    //
-    // If a jsRepresentation is found on the TurboModule, return it.
-    //
-    // Note: TurboModules are cached by name in TurboModuleManagers. Hence,
-    // jsRepresentation is also cached by by name by the TurboModuleManager
-    auto& weakJsRepresentation = module->jsRepresentation_;
+    // Default behaviour
+    if (bindingMode_ == TurboModuleBindingMode::HostObject) {
+      return jsi::Object::createFromHostObject(runtime, std::move(module));
+    }
+
+    auto &weakJsRepresentation = module->jsRepresentation_;
     if (weakJsRepresentation) {
       auto jsRepresentation = weakJsRepresentation->lock(runtime);
       if (!jsRepresentation.isUndefined()) {
@@ -172,29 +89,28 @@ jsi::Value TurboModuleBinding::getModule(
       }
     }
 
-    // Status: No jsRepresentation found on TurboModule
-    // Create a brand new jsRepresentation, and attach it to TurboModule
+    // No JS representation found, or object has been collected
     jsi::Object jsRepresentation(runtime);
     weakJsRepresentation =
         std::make_unique<jsi::WeakObject>(runtime, jsRepresentation);
 
-    // Lazily populate the jsRepresentation, on property access.
-    //
-    // How does this work?
-    //   1. Initially jsRepresentation is empty: {}
-    //   2. If property lookup on jsRepresentation fails, the JS runtime will
-    //   search jsRepresentation's prototype: jsi::Object(TurboModule).
-    //   3. TurboModule::get(runtime, propKey) executes. This creates the
-    //   property, caches it on jsRepresentation, then returns it to
-    //   JavaScript.
-    auto hostObject =
-        jsi::Object::createFromHostObject(runtime, std::move(module));
-    jsRepresentation.setProperty(runtime, "__proto__", std::move(hostObject));
-
+    if (bindingMode_ == TurboModuleBindingMode::Prototype) {
+      // Option 1: create plain object, with it's prototype mapped back to the
+      // hostobject. Any properties accessed are stored on the plain object
+      auto hostObject =
+          jsi::Object::createFromHostObject(runtime, std::move(module));
+      jsRepresentation.setProperty(runtime, "__proto__", std::move(hostObject));
+    } else {
+      // Option 2: eagerly install all hostfunctions at this point, avoids
+      // prototype
+      for (auto &propName : module->getPropertyNames(runtime)) {
+        module->get(runtime, propName);
+      }
+    }
     return jsRepresentation;
   } else {
     return jsi::Value::null();
   }
 }
-
-} // namespace facebook::react
+} // namespace react
+} // namespace facebook
\ No newline at end of file
diff --git a/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleBinding.h b/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleBinding.h
index 385ce24..550f7c3 100644
--- a/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleBinding.h
+++ b/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleBinding.h
@@ -5,17 +5,23 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#pragma once
+// [Windows - see issue #11019, this file is an older version]
 
+#pragma once
 #include <string>
-
+#include <ReactCommon/LongLivedObject.h>
 #include <ReactCommon/TurboModule.h>
 #include <jsi/jsi.h>
+namespace facebook {
+namespace react {
 
-namespace facebook::react {
-
-class BridgelessNativeModuleProxy;
+class JSCallInvoker;
 
+enum class TurboModuleBindingMode : uint8_t {
+  HostObject = 0,
+  Prototype = 1,
+  Eager = 2,
+};
 /**
  * Represents the JavaScript binding for the TurboModule system.
  */
@@ -26,24 +32,32 @@ class TurboModuleBinding {
    * Thread synchronization must be enforced externally.
    */
   static void install(
-      jsi::Runtime& runtime,
-      TurboModuleProviderFunctionType&& moduleProvider,
-      TurboModuleProviderFunctionType&& legacyModuleProvider = nullptr);
-
-  TurboModuleBinding(TurboModuleProviderFunctionType&& moduleProvider);
-  virtual ~TurboModuleBinding();
+      jsi::Runtime &runtime,
+      const TurboModuleProviderFunctionType &&moduleProvider,
+      TurboModuleBindingMode bindingMode,
+      std::shared_ptr<LongLivedObjectCollection> longLivedObjectCollection);
 
  private:
-  friend BridgelessNativeModuleProxy;
+  TurboModuleBinding(
+      const TurboModuleProviderFunctionType &&moduleProvider,
+      TurboModuleBindingMode bindingMode,
+      std::shared_ptr<LongLivedObjectCollection> longLivedObjectCollection);
+  virtual ~TurboModuleBinding();
 
   /**
    * A lookup function exposed to JS to get an instance of a TurboModule
    * for the given name.
    */
-  jsi::Value getModule(jsi::Runtime& runtime, const std::string& moduleName)
-      const;
+  jsi::Value getModule(
+      jsi::Runtime &runtime,
+      const jsi::Value &thisVal,
+      const jsi::Value *args,
+      size_t count);
 
   TurboModuleProviderFunctionType moduleProvider_;
+  std::shared_ptr<LongLivedObjectCollection> longLivedObjectCollection_;
+  TurboModuleBindingMode bindingMode_;
 };
 
-} // namespace facebook::react
+} // namespace react
+} // namespace facebook
\ No newline at end of file
diff --git a/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleUtils.h b/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleUtils.h
index d255825..bf2c6d6 100644
--- a/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleUtils.h
+++ b/node_modules/react-native/ReactCommon/react/nativemodule/core/ReactCommon/TurboModuleUtils.h
@@ -13,29 +13,30 @@
 #include <jsi/jsi.h>
 
 #include <ReactCommon/CallInvoker.h>
-#include <ReactCommon/CallbackWrapper.h>
+#include <CallbackWrapper.h>
 
-namespace facebook::react {
+namespace facebook {
+namespace react {
 
-jsi::Object deepCopyJSIObject(jsi::Runtime& rt, const jsi::Object& obj);
-jsi::Array deepCopyJSIArray(jsi::Runtime& rt, const jsi::Array& arr);
+jsi::Object deepCopyJSIObject(jsi::Runtime &rt, const jsi::Object &obj);
+jsi::Array deepCopyJSIArray(jsi::Runtime &rt, const jsi::Array &arr);
 
 struct Promise : public LongLivedObject {
-  Promise(jsi::Runtime& rt, jsi::Function resolve, jsi::Function reject);
+  Promise(jsi::Runtime &rt, jsi::Function resolve, jsi::Function reject);
 
-  void resolve(const jsi::Value& result);
-  void reject(const std::string& error);
+  void resolve(const jsi::Value &result);
+  void reject(const std::string &error);
 
-  jsi::Runtime& runtime_;
+  jsi::Runtime &runtime_;
   jsi::Function resolve_;
   jsi::Function reject_;
 };
 
 using PromiseSetupFunctionType =
-    std::function<void(jsi::Runtime& rt, std::shared_ptr<Promise>)>;
+    std::function<void(jsi::Runtime &rt, std::shared_ptr<Promise>)>;
 jsi::Value createPromiseAsJSIValue(
-    jsi::Runtime& rt,
-    PromiseSetupFunctionType&& func);
+    jsi::Runtime &rt,
+    PromiseSetupFunctionType &&func);
 
 class RAIICallbackWrapperDestroyer {
  public:
@@ -55,4 +56,6 @@ class RAIICallbackWrapperDestroyer {
   std::weak_ptr<CallbackWrapper> callbackWrapper_;
 };
 
-} // namespace facebook::react
+} // namespace react
+} // namespace facebook
+
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaLayoutableShadowNode.cpp b/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaLayoutableShadowNode.cpp
index 2933ee9..cae9474 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaLayoutableShadowNode.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/YogaLayoutableShadowNode.cpp
@@ -276,7 +276,7 @@ void YogaLayoutableShadowNode::replaceChild(
   }
 
   bool suggestedIndexAccurate = suggestedIndex >= 0 &&
-      suggestedIndex < yogaLayoutableChildren_.size() &&
+      suggestedIndex < static_cast<int32_t>(yogaLayoutableChildren_.size()) &&
       yogaLayoutableChildren_[suggestedIndex].get() == layoutableOldChild;
 
   auto oldChildIter = suggestedIndexAccurate
diff --git a/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h b/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h
index ca969ed..e38ab6b 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h
+++ b/node_modules/react-native/ReactCommon/react/renderer/components/view/conversions.h
@@ -866,7 +866,7 @@ inline std::string toString(const yoga::Style::Edges& value) {
   auto result = std::string{};
   auto separator = std::string{", "};
 
-  for (auto i = 0; i < names.size(); i++) {
+  for (size_t i = 0; i < names.size(); i++) {
     YGValue v = value[i];
     if (v.unit == YGUnitUndefined) {
       continue;
diff --git a/node_modules/react-native/ReactCommon/react/renderer/mapbuffer/MapBufferBuilder.cpp b/node_modules/react-native/ReactCommon/react/renderer/mapbuffer/MapBufferBuilder.cpp
index e2ca2d5..685803a 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/mapbuffer/MapBufferBuilder.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/mapbuffer/MapBufferBuilder.cpp
@@ -10,7 +10,8 @@
 
 using namespace facebook::react;
 
-namespace facebook::react {
+namespace facebook {
+namespace react {
 
 constexpr uint32_t INT_SIZE = sizeof(uint32_t);
 constexpr uint32_t DOUBLE_SIZE = sizeof(double);
@@ -29,7 +30,7 @@ MapBufferBuilder::MapBufferBuilder(uint32_t initialSize) {
 void MapBufferBuilder::storeKeyValue(
     MapBuffer::Key key,
     MapBuffer::DataType type,
-    const uint8_t* value,
+    uint8_t const *value,
     uint32_t valueSize) {
   if (valueSize > MAX_BUCKET_VALUE_SIZE) {
     LOG(ERROR) << "Error: size of value must be <= MAX_VALUE_SIZE. ValueSize: "
@@ -38,7 +39,7 @@ void MapBufferBuilder::storeKeyValue(
   }
 
   uint64_t data = 0;
-  auto* dataPtr = reinterpret_cast<uint8_t*>(&data);
+  auto *dataPtr = reinterpret_cast<uint8_t *>(&data);
   memcpy(dataPtr, value, valueSize);
 
   buckets_.emplace_back(key, static_cast<uint16_t>(type), data);
@@ -56,7 +57,7 @@ void MapBufferBuilder::putBool(MapBuffer::Key key, bool value) {
   storeKeyValue(
       key,
       MapBuffer::DataType::Boolean,
-      reinterpret_cast<const uint8_t*>(&intValue),
+      reinterpret_cast<uint8_t const *>(&intValue),
       INT_SIZE);
 }
 
@@ -64,7 +65,7 @@ void MapBufferBuilder::putDouble(MapBuffer::Key key, double value) {
   storeKeyValue(
       key,
       MapBuffer::DataType::Double,
-      reinterpret_cast<const uint8_t*>(&value),
+      reinterpret_cast<uint8_t const *>(&value),
       DOUBLE_SIZE);
 }
 
@@ -72,13 +73,13 @@ void MapBufferBuilder::putInt(MapBuffer::Key key, int32_t value) {
   storeKeyValue(
       key,
       MapBuffer::DataType::Int,
-      reinterpret_cast<const uint8_t*>(&value),
+      reinterpret_cast<uint8_t const *>(&value),
       INT_SIZE);
 }
 
-void MapBufferBuilder::putString(MapBuffer::Key key, const std::string& value) {
+void MapBufferBuilder::putString(MapBuffer::Key key, std::string const &value) {
   auto strSize = value.size();
-  const char* strData = value.data();
+  const char *strData = value.data();
 
   // format [length of string (int)] + [Array of Characters in the string]
   auto offset = dynamicData_.size();
@@ -90,11 +91,11 @@ void MapBufferBuilder::putString(MapBuffer::Key key, const std::string& value) {
   storeKeyValue(
       key,
       MapBuffer::DataType::String,
-      reinterpret_cast<const uint8_t*>(&offset),
+      reinterpret_cast<uint8_t const *>(&offset),
       INT_SIZE);
 }
 
-void MapBufferBuilder::putMapBuffer(MapBuffer::Key key, const MapBuffer& map) {
+void MapBufferBuilder::putMapBuffer(MapBuffer::Key key, MapBuffer const &map) {
   auto mapBufferSize = map.size();
 
   auto offset = dynamicData_.size();
@@ -109,25 +110,25 @@ void MapBufferBuilder::putMapBuffer(MapBuffer::Key key, const MapBuffer& map) {
   storeKeyValue(
       key,
       MapBuffer::DataType::Map,
-      reinterpret_cast<const uint8_t*>(&offset),
+      reinterpret_cast<uint8_t const *>(&offset),
       INT_SIZE);
 }
 
 void MapBufferBuilder::putMapBufferList(
     MapBuffer::Key key,
-    const std::vector<MapBuffer>& mapBufferList) {
-  int32_t offset = dynamicData_.size();
-  int32_t dataSize = 0;
-  for (const MapBuffer& mapBuffer : mapBufferList) {
+    const std::vector<MapBuffer> &mapBufferList) {
+  auto offset = dynamicData_.size();
+  size_t dataSize = 0;
+  for (const MapBuffer &mapBuffer : mapBufferList) {
     dataSize = dataSize + INT_SIZE + mapBuffer.size();
   }
 
   dynamicData_.resize(offset + INT_SIZE, 0);
   memcpy(dynamicData_.data() + offset, &dataSize, INT_SIZE);
 
-  for (const MapBuffer& mapBuffer : mapBufferList) {
-    int32_t mapBufferSize = mapBuffer.size();
-    int32_t dynamicDataSize = dynamicData_.size();
+  for (const MapBuffer &mapBuffer : mapBufferList) {
+    auto mapBufferSize = mapBuffer.size();
+    auto dynamicDataSize = dynamicData_.size();
     dynamicData_.resize(dynamicDataSize + INT_SIZE + mapBufferSize, 0);
     // format [length of buffer (int)] + [bytes of MapBuffer]
     memcpy(dynamicData_.data() + dynamicDataSize, &mapBufferSize, INT_SIZE);
@@ -142,13 +143,13 @@ void MapBufferBuilder::putMapBufferList(
   storeKeyValue(
       key,
       MapBuffer::DataType::Map,
-      reinterpret_cast<const uint8_t*>(&offset),
+      reinterpret_cast<uint8_t const *>(&offset),
       INT_SIZE);
 }
 
 static inline bool compareBuckets(
-    const MapBuffer::Bucket& a,
-    const MapBuffer::Bucket& b) {
+    MapBuffer::Bucket const &a,
+    MapBuffer::Bucket const &b) {
   return a.key < b.key;
 }
 
@@ -177,4 +178,5 @@ MapBuffer MapBufferBuilder::build() {
   return MapBuffer(std::move(buffer));
 }
 
-} // namespace facebook::react
+} // namespace react
+} // namespace facebook
\ No newline at end of file
diff --git a/node_modules/react-native/ReactCommon/react/renderer/mounting/ShadowTree.cpp b/node_modules/react-native/ReactCommon/react/renderer/mounting/ShadowTree.cpp
index 563f3c3..0cac4f6 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/mounting/ShadowTree.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/mounting/ShadowTree.cpp
@@ -427,7 +427,7 @@ CommitStatus ShadowTree::tryCommit(
   telemetry.setAsThreadLocal();
   newRootShadowNode->layoutIfNeeded(&affectedLayoutableNodes);
   telemetry.unsetAsThreadLocal();
-  telemetry.didLayout(affectedLayoutableNodes.size());
+  telemetry.didLayout(static_cast<int>(affectedLayoutableNodes.size()));
 
   {
     // Updating `currentRevision_` in unique manner if it hasn't changed.
diff --git a/node_modules/react-native/ReactCommon/react/renderer/uimanager/UIManagerBinding.cpp b/node_modules/react-native/ReactCommon/react/renderer/uimanager/UIManagerBinding.cpp
index c00411b..a7e377f 100644
--- a/node_modules/react-native/ReactCommon/react/renderer/uimanager/UIManagerBinding.cpp
+++ b/node_modules/react-native/ReactCommon/react/renderer/uimanager/UIManagerBinding.cpp
@@ -471,6 +471,7 @@ jsi::Value UIManagerBinding::get(
           auto runtimeSchedulerBinding =
               RuntimeSchedulerBinding::getBinding(runtime);
           auto surfaceId = surfaceIdFromValue(runtime, arguments[0]);
+          ShadowTree::CommitOptions options = {/* .enableStateReconciliation = */ true, /* .mountSynchronously = */ false};
 
           if (!uiManager->backgroundExecutor_ ||
               (runtimeSchedulerBinding &&
@@ -483,8 +484,7 @@ jsi::Value UIManagerBinding::get(
               uiManager->completeSurface(
                   surfaceId,
                   shadowNodeList,
-                  {/* .enableStateReconciliation = */ true,
-                   /* .mountSynchronously = */ false});
+                  options);
             }
           } else {
             auto weakShadowNodeList =
@@ -508,13 +508,12 @@ jsi::Value UIManagerBinding::get(
                   auto shadowNodeList =
                       shadowNodeListFromWeakList(weakShadowNodeList);
                   auto strongUIManager = weakUIManager.lock();
+                  ShadowTree::CommitOptions options = {/* .enableStateReconciliation = */ true, /* .mountSynchronously = */ false, /* .shouldYield = */ shouldYield};
                   if (shadowNodeList && strongUIManager) {
                     strongUIManager->completeSurface(
                         surfaceId,
                         shadowNodeList,
-                        {/* .enableStateReconciliation = */ true,
-                         /* .mountSynchronously = */ false,
-                         /* .shouldYield = */ shouldYield});
+                        options);
                   }
                 });
           }
@@ -556,11 +555,12 @@ jsi::Value UIManagerBinding::get(
             const jsi::Value* arguments,
             size_t count) -> jsi::Value {
           validateArgumentCount(runtime, methodName, paramCount, count);
+          LayoutableShadowNode::LayoutInspectingPolicy policy = {/* .includeTransform = */ true};
 
           auto layoutMetrics = uiManager->getRelativeLayoutMetrics(
               *shadowNodeFromValue(runtime, arguments[0]),
               shadowNodeFromValue(runtime, arguments[1]).get(),
-              {/* .includeTransform = */ true});
+              policy);
           auto frame = layoutMetrics.frame;
           auto result = jsi::Object(runtime);
           result.setProperty(runtime, "left", frame.origin.x);
@@ -630,10 +630,12 @@ jsi::Value UIManagerBinding::get(
             size_t count) {
           validateArgumentCount(runtime, methodName, paramCount, count);
 
+          LayoutableShadowNode::LayoutInspectingPolicy policy = {/* .includeTransform = */ false};
+
           auto layoutMetrics = uiManager->getRelativeLayoutMetrics(
               *shadowNodeFromValue(runtime, arguments[0]),
               shadowNodeFromValue(runtime, arguments[1]).get(),
-              {/* .includeTransform = */ false});
+              policy);
 
           if (layoutMetrics == EmptyLayoutMetrics) {
             auto onFailFunction =
@@ -648,10 +650,10 @@ jsi::Value UIManagerBinding::get(
 
           onSuccessFunction.call(
               runtime,
-              {jsi::Value{runtime, (double)frame.origin.x},
-               jsi::Value{runtime, (double)frame.origin.y},
-               jsi::Value{runtime, (double)frame.size.width},
-               jsi::Value{runtime, (double)frame.size.height}});
+              {jsi::Value{(double)frame.origin.x},
+               jsi::Value{(double)frame.origin.y},
+               jsi::Value{(double)frame.size.width},
+               jsi::Value{(double)frame.size.height}});
           return jsi::Value::undefined();
         });
   }
@@ -669,9 +671,11 @@ jsi::Value UIManagerBinding::get(
             size_t count) {
           validateArgumentCount(runtime, methodName, paramCount, count);
 
+          LayoutableShadowNode::LayoutInspectingPolicy policy = {/* .includeTransform = */ false};
+
           auto shadowNode = shadowNodeFromValue(runtime, arguments[0]);
           auto layoutMetrics = uiManager->getRelativeLayoutMetrics(
-              *shadowNode, nullptr, {/* .includeTransform = */ true});
+              *shadowNode, nullptr, policy);
           auto onSuccessFunction =
               arguments[1].getObject(runtime).getFunction(runtime);
 
@@ -691,12 +695,12 @@ jsi::Value UIManagerBinding::get(
           auto frame = layoutMetrics.frame;
           onSuccessFunction.call(
               runtime,
-              {jsi::Value{runtime, (double)originRelativeToParent.x},
-               jsi::Value{runtime, (double)originRelativeToParent.y},
-               jsi::Value{runtime, (double)frame.size.width},
-               jsi::Value{runtime, (double)frame.size.height},
-               jsi::Value{runtime, (double)frame.origin.x},
-               jsi::Value{runtime, (double)frame.origin.y}});
+              {jsi::Value{(double)originRelativeToParent.x},
+               jsi::Value{(double)originRelativeToParent.y},
+               jsi::Value{(double)frame.size.width},
+               jsi::Value{(double)frame.size.height},
+               jsi::Value{(double)frame.origin.x},
+               jsi::Value{(double)frame.origin.y}});
           return jsi::Value::undefined();
         });
   }
@@ -714,11 +718,12 @@ jsi::Value UIManagerBinding::get(
             size_t count) {
           validateArgumentCount(runtime, methodName, paramCount, count);
 
+          LayoutableShadowNode::LayoutInspectingPolicy policy = {/* .includeTransform = */ false, /* .includeViewportOffset = */ true};
+
           auto layoutMetrics = uiManager->getRelativeLayoutMetrics(
               *shadowNodeFromValue(runtime, arguments[0]),
               nullptr,
-              {/* .includeTransform = */ true,
-               /* .includeViewportOffset = */ true});
+              policy);
 
           auto onSuccessFunction =
               arguments[1].getObject(runtime).getFunction(runtime);
@@ -731,10 +736,10 @@ jsi::Value UIManagerBinding::get(
           auto frame = layoutMetrics.frame;
           onSuccessFunction.call(
               runtime,
-              {jsi::Value{runtime, (double)frame.origin.x},
-               jsi::Value{runtime, (double)frame.origin.y},
-               jsi::Value{runtime, (double)frame.size.width},
-               jsi::Value{runtime, (double)frame.size.height}});
+              {jsi::Value{(double)frame.origin.x},
+               jsi::Value{(double)frame.origin.y},
+               jsi::Value{(double)frame.size.width},
+               jsi::Value{(double)frame.size.height}});
           return jsi::Value::undefined();
         });
   }
@@ -867,12 +872,12 @@ jsi::Value UIManagerBinding::get(
           validateArgumentCount(runtime, methodName, paramCount, count);
 
           bool includeTransform = arguments[1].getBool();
+          LayoutableShadowNode::LayoutInspectingPolicy policy = {/* .includeTransform = */ includeTransform, /* .includeViewportOffset = */ true};
 
           auto layoutMetrics = uiManager->getRelativeLayoutMetrics(
               *shadowNodeFromValue(runtime, arguments[0]),
               nullptr,
-              {/* .includeTransform = */ includeTransform,
-               /* .includeViewportOffset = */ true});
+              policy);
 
           if (layoutMetrics == EmptyLayoutMetrics) {
             return jsi::Value::undefined();
@@ -881,10 +886,10 @@ jsi::Value UIManagerBinding::get(
           auto frame = layoutMetrics.frame;
           return jsi::Array::createWithElements(
               runtime,
-              jsi::Value{runtime, (double)frame.origin.x},
-              jsi::Value{runtime, (double)frame.origin.y},
-              jsi::Value{runtime, (double)frame.size.width},
-              jsi::Value{runtime, (double)frame.size.height});
+              jsi::Value{(double)frame.origin.x},
+              jsi::Value{(double)frame.origin.y},
+              jsi::Value{(double)frame.size.width},
+              jsi::Value{(double)frame.size.height});
         });
   }
 
@@ -1106,10 +1111,12 @@ jsi::Value UIManagerBinding::get(
             return jsi::Value::undefined();
           }
 
+          LayoutableShadowNode::LayoutInspectingPolicy policy = {/* .includeTransform = */ false};
+
           // If the node is not displayed (itself or any of its ancestors has
           // "display: none"), this returns an empty layout metrics object.
           auto layoutMetrics = uiManager->getRelativeLayoutMetrics(
-              *shadowNode, nullptr, {/* .includeTransform = */ false});
+              *shadowNode, nullptr, policy);
 
           if (layoutMetrics == EmptyLayoutMetrics) {
             return jsi::Value::undefined();
@@ -1143,8 +1150,8 @@ jsi::Value UIManagerBinding::get(
           return jsi::Array::createWithElements(
               runtime,
               (*newestParentOfShadowNode).getInstanceHandle(runtime),
-              jsi::Value{runtime, (double)offsetTop},
-              jsi::Value{runtime, (double)offsetLeft});
+              jsi::Value{(double)offsetTop},
+              jsi::Value{(double)offsetLeft});
         });
   }
 
@@ -1188,10 +1195,12 @@ jsi::Value UIManagerBinding::get(
             return jsi::Value::undefined();
           }
 
+          LayoutableShadowNode::LayoutInspectingPolicy policy = {/* .includeTransform = */ false};
+
           // If the node is not displayed (itself or any of its ancestors has
           // "display: none"), this returns an empty layout metrics object.
           auto layoutMetrics = uiManager->getRelativeLayoutMetrics(
-              *shadowNode, nullptr, {/* .includeTransform = */ true});
+              *shadowNode, nullptr, policy);
 
           if (layoutMetrics == EmptyLayoutMetrics) {
             return jsi::Value::undefined();
@@ -1208,12 +1217,8 @@ jsi::Value UIManagerBinding::get(
 
           return jsi::Array::createWithElements(
               runtime,
-              jsi::Value{
-                  runtime,
-                  scrollPosition.x == 0 ? 0 : (double)-scrollPosition.x},
-              jsi::Value{
-                  runtime,
-                  scrollPosition.y == 0 ? 0 : (double)-scrollPosition.y});
+              jsi::Value{scrollPosition.x == 0 ? 0 : (double)-scrollPosition.x},
+              jsi::Value{scrollPosition.y == 0 ? 0 : (double)-scrollPosition.y});
         });
   }
 
@@ -1257,10 +1262,12 @@ jsi::Value UIManagerBinding::get(
             return jsi::Value::undefined();
           }
 
+          LayoutableShadowNode::LayoutInspectingPolicy policy = {/* .includeTransform = */ false};
+
           // If the node is not displayed (itself or any of its ancestors has
           // "display: none"), this returns an empty layout metrics object.
           auto layoutMetrics = uiManager->getRelativeLayoutMetrics(
-              *shadowNode, nullptr, {/* .includeTransform = */ false});
+              *shadowNode, nullptr, policy);
 
           if (layoutMetrics == EmptyLayoutMetrics ||
               layoutMetrics.displayType == DisplayType::Inline) {
@@ -1280,8 +1287,8 @@ jsi::Value UIManagerBinding::get(
 
           return jsi::Array::createWithElements(
               runtime,
-              jsi::Value{runtime, std::round(scrollSize.width)},
-              jsi::Value{runtime, std::round(scrollSize.height)});
+              jsi::Value{(double)std::round(scrollSize.width)},
+              jsi::Value{(double)std::round(scrollSize.height)});
         });
   }
 
@@ -1317,11 +1324,11 @@ jsi::Value UIManagerBinding::get(
           validateArgumentCount(runtime, methodName, paramCount, count);
 
           auto shadowNode = shadowNodeFromValue(runtime, arguments[0]);
-
+          LayoutableShadowNode::LayoutInspectingPolicy policy = {/* .includeTransform = */ false};
           // If the node is not displayed (itself or any of its ancestors has
           // "display: none"), this returns an empty layout metrics object.
           auto layoutMetrics = uiManager->getRelativeLayoutMetrics(
-              *shadowNode, nullptr, {/* .includeTransform = */ false});
+              *shadowNode, nullptr, policy);
 
           if (layoutMetrics == EmptyLayoutMetrics ||
               layoutMetrics.displayType == DisplayType::Inline) {
@@ -1332,8 +1339,8 @@ jsi::Value UIManagerBinding::get(
 
           return jsi::Array::createWithElements(
               runtime,
-              jsi::Value{runtime, std::round(paddingFrame.size.width)},
-              jsi::Value{runtime, std::round(paddingFrame.size.height)});
+              jsi::Value{(double)std::round(paddingFrame.size.width)},
+              jsi::Value{(double)std::round(paddingFrame.size.height)});
         });
   }
 
@@ -1371,11 +1378,11 @@ jsi::Value UIManagerBinding::get(
           validateArgumentCount(runtime, methodName, paramCount, count);
 
           auto shadowNode = shadowNodeFromValue(runtime, arguments[0]);
-
+          LayoutableShadowNode::LayoutInspectingPolicy policy = {/* .includeTransform = */ false};
           // If the node is not displayed (itself or any of its ancestors has
           // "display: none"), this returns an empty layout metrics object.
           auto layoutMetrics = uiManager->getRelativeLayoutMetrics(
-              *shadowNode, nullptr, {/* .includeTransform = */ false});
+              *shadowNode, nullptr, policy);
 
           if (layoutMetrics == EmptyLayoutMetrics ||
               layoutMetrics.displayType == DisplayType::Inline) {
@@ -1384,10 +1391,10 @@ jsi::Value UIManagerBinding::get(
 
           return jsi::Array::createWithElements(
               runtime,
-              jsi::Value{runtime, std::round(layoutMetrics.borderWidth.top)},
-              jsi::Value{runtime, std::round(layoutMetrics.borderWidth.right)},
-              jsi::Value{runtime, std::round(layoutMetrics.borderWidth.bottom)},
-              jsi::Value{runtime, std::round(layoutMetrics.borderWidth.left)});
+              jsi::Value{(double)std::round(layoutMetrics.borderWidth.top)},
+              jsi::Value{(double)std::round(layoutMetrics.borderWidth.right)},
+              jsi::Value{(double)std::round(layoutMetrics.borderWidth.bottom)},
+              jsi::Value{(double)std::round(layoutMetrics.borderWidth.left)});
         });
   }
 
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/bits/NumericBitfield.h b/node_modules/react-native/ReactCommon/yoga/yoga/bits/NumericBitfield.h
index 63f7eb6..35c71ba 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/bits/NumericBitfield.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/bits/NumericBitfield.h
@@ -34,7 +34,7 @@ template <
     typename Enum,
     std::enable_if_t<(ordinalCount<Enum>() > 0), bool> = true>
 constexpr uint8_t minimumBitCount() {
-  return details::log2ceilFn(ordinalCount<Enum>() - 1);
+  return details::log2ceilFn(static_cast<uint8_t>(ordinalCount<Enum>()) - 1);
 }
 
 template <typename Enum>
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/config/Config.h b/node_modules/react-native/ReactCommon/yoga/yoga/config/Config.h
index 1bdc046..344d3d1 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/config/Config.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/config/Config.h
@@ -73,8 +73,8 @@ class YG_EXPORT Config : public ::YGConfig {
   YGCloneNodeFunc cloneNodeCallback_;
   YGLogger logger_;
 
-  bool useWebDefaults_ : 1 = false;
-  bool printTree_ : 1 = false;
+  bool useWebDefaults_ = false;
+  bool printTree_ = false;
 
   ExperimentalFeatureSet experimentalFeatures_{};
   Errata errata_ = Errata::None;
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/node/LayoutResults.h b/node_modules/react-native/ReactCommon/yoga/yoga/node/LayoutResults.h
index df00993..1d05d96 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/node/LayoutResults.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/node/LayoutResults.h
@@ -27,8 +27,8 @@ struct LayoutResults {
   std::array<float, 4> padding = {};
 
  private:
-  Direction direction_ : bitCount<Direction>() = Direction::Inherit;
-  bool hadOverflow_ : 1 = false;
+  Direction direction_ = Direction::Inherit;
+  bool hadOverflow_ = false;
 
   std::array<float, 2> dimensions_ = {{YGUndefined, YGUndefined}};
   std::array<float, 2> measuredDimensions_ = {{YGUndefined, YGUndefined}};
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.cpp
index 215b5f3..32e3343 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.cpp
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.cpp
@@ -302,19 +302,19 @@ void Node::setLayoutDirection(Direction direction) {
 
 void Node::setLayoutMargin(float margin, YGEdge edge) {
   assertFatal(
-      edge < layout_.margin.size(), "Edge must be top/left/bottom/right");
+      edge < static_cast<int>(layout_.margin.size()), "Edge must be top/left/bottom/right");
   layout_.margin[edge] = margin;
 }
 
 void Node::setLayoutBorder(float border, YGEdge edge) {
   assertFatal(
-      edge < layout_.border.size(), "Edge must be top/left/bottom/right");
+      edge < static_cast<int>(layout_.border.size()), "Edge must be top/left/bottom/right");
   layout_.border[edge] = border;
 }
 
 void Node::setLayoutPadding(float padding, YGEdge edge) {
   assertFatal(
-      edge < layout_.padding.size(), "Edge must be top/left/bottom/right");
+      edge < static_cast<int>(layout_.padding.size()), "Edge must be top/left/bottom/right");
   layout_.padding[edge] = padding;
 }
 
@@ -328,7 +328,7 @@ void Node::setLayoutComputedFlexBasis(const FloatOptional computedFlexBasis) {
 
 void Node::setLayoutPosition(float position, YGEdge edge) {
   assertFatal(
-      edge < layout_.position.size(), "Edge must be top/left/bottom/right");
+      edge < static_cast<int>(layout_.position.size()), "Edge must be top/left/bottom/right");
   layout_.position[edge] = position;
 }
 
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h b/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h
index 359df85..c00c92e 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/node/Node.h
@@ -29,10 +29,10 @@ namespace facebook::yoga {
 
 class YG_EXPORT Node : public ::YGNode {
  private:
-  bool hasNewLayout_ : 1 = true;
-  bool isReferenceBaseline_ : 1 = false;
-  bool isDirty_ : 1 = false;
-  NodeType nodeType_ : bitCount<NodeType>() = NodeType::Default;
+  bool hasNewLayout_ = true;
+  bool isReferenceBaseline_ = false;
+  bool isDirty_ = false;
+  NodeType nodeType_ = NodeType::Default;
   void* context_ = nullptr;
   YGMeasureFunc measureFunc_ = {nullptr};
   YGBaselineFunc baselineFunc_ = {nullptr};
diff --git a/node_modules/react-native/index.js b/node_modules/react-native/index.js
index 7149c64..6bb0079 100644
--- a/node_modules/react-native/index.js
+++ b/node_modules/react-native/index.js
@@ -410,13 +410,6 @@ module.exports = {
     return require('deprecated-react-native-prop-types').PointPropType;
   },
   get ViewPropTypes(): $FlowFixMe {
-    console.error(
-      'ViewPropTypes will be removed from React Native, along with all ' +
-        'other PropTypes. We recommend that you migrate away from PropTypes ' +
-        'and switch to a type system like TypeScript. If you need to ' +
-        'continue using ViewPropTypes, migrate to the ' +
-        "'deprecated-react-native-prop-types' package.",
-    );
     return require('deprecated-react-native-prop-types').ViewPropTypes;
   },
 };
